### ARP

发广播的目的：获取对方的mac地址：
例如：192.168.1.20想向192.168.1.21发数据，它先广播：192.168.1.21的mac地址是多少，当192.168.1.21收到广播发现在问自己，就会将自己的mac地址返回给192.168.1.20,这样192.168.1.20就有了目标的mac地址。在广播过程中，目标mac开始是FFFF.FFFF.FFFF，表示 谁都同网段谁都可以收到。只有通过arp协议获取到目标mac，再次发包，目标mac就换成了获取到的mac. ARP协议会缓存mac地址，第一次获取到后，第二次发送就会直接发送。

广播在同一网段中传播，不同网段中不能广播. 

半双工通信：同一时间只能有一方发送消息通信，比如A,B之前通过同轴电缆连接起来了，当A给B发消息时，B不能给A发消息。

集线器发送包也是广播，所有相连的设备都会发送消息，只有目标会回复。

网桥能通过自学习得知每个接口那侧的mac地址

### MAC地址
六字节（49bit)的 media access control address 
mac地址查询：https://mac.bmcx.com/
```
40-55-82         0A-8C-6D   
组织唯一标识      网络接口标识符
```

### ip地址
ip有两部分组成：网络标识，主机标识
同一网段，网络标识（网络ID相同）
网段的计算方法： 子网掩码 & ip地址
示例：
```
ip:192.168.1.10
subnet:255.255.255.0

1100 0000 1010 1000 0000 0001 0000 1010
1111 1111 1111 1111 1111 1111 0000 0000

1100 0000 1010 1000 0000 0001 0000 0000
192.168.1.0
```

### 物理层


网络分层

![0010%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82](vimages/509942096838.jpg =390x)
分层的意思是，例如网络层发送icmp，它其实是没有上面的应用层，运输层的数据的，它本身只有icmp的数据

### 数据链路层

![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_01](vimages/285505158970.jpg =800x)

不同类型的数据链路，使用的协议不同是针对这里说的的数据链路层，比如，数据链路层中的广播信道 使用CSMA协议。

为了检测发送的帧是否产生了冲突，以太网帧最少要64byte
![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_06_csma%E5%86%B2%E7%AA%81](vimages/287619171981.jpg =592x)

当数据帧从A发送到b,如果a没有发完，而b却开始返回数据了，两者在中间相遇，a的数据会被弹回，当返回到a时，发现a仍在发，此时就知道返回的数据是冲突数据，否则无法知道是否是冲突。这样看至少是两倍的a,b之间的包长度（不知如何表述），64字节


数据链路层将数据封装成贝帧：
![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_02](vimages/5351326146837.jpg =526x)

数据链路层---透明传输
透明传输是为了解决字节冲突的问题：帧的结束或者开始也是一个字节标志，当ip数据包中有相同字节时，如果不作处理，就会被错误识别为帧的开始或者结束。

![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_03](vimages/1400532167003.jpg =597x)

透明传输的原理图：当数据中出现了特殊字符，在链路中会加上ESC，到达目标结点又会将ESC去掉，从而避免数据解析错误的问题。 这里需要注意的是，仅仅是将原始数据中的特殊字符进行处理，而帧开始和结尾的并不处理。
![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_04](vimages/5163935159672.jpg =690x)


差错校验：
![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_05_%E5%B7%AE%E9%94%99%E6%A3%80%E9%AA%8C](vimages/5852841156227.jpg =459x)

这里的差错校验，我的理解是类型于文件的Md5值校验，FCS是根据帧的数据部分+首部进行计算得出的，当内容发生变化计算的结果也会变化，从而与传输的FCS发生变化，说明
数据出错了，可能是解析出错，也可能是别的原因。那么两者不一致，网卡会将数据丢掉。而如果两者FCS一致，网卡会将FCS丢掉，所以抓包是抓不到FCS的。


以太网v2帧结构

![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_07%E4%BB%A5%E5%A4%AA%E7%BD%91v2%E5%B8%A7%E7%BB%93%E6%9E%84](vimages/5419635189861.jpg =657x)


ppp

![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_08ppp%E5%8D%8F%E8%AE%AEjpg](vimages/3859959187465.jpg =567x)
ppp协议数据部分与数据链路层的数据部分一样，不能超过1500byte, mtu

网卡
![%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82_09%E7%BD%91%E5%8D%A1](vimages/1839808194967.jpg =719x)

### 网络层

网络层包结构
![10_%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8C%85%E7%BB%93%E6%9E%84](vimages/4838029176208.jpg =617x)

对应的字段:

![0011%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8C%85%E5%AD%97%E6%AE%B5](vimages/1863434080545.jpg)

首部的分为两部分，固定部分共5x4bytes 共20字节。需要注意的是，首部中：首部长度为二进制表示：0101 即5 。 5x4区20字节

标识，标志

![0012%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8C%85%E6%A0%87%E7%A4%BA%E6%A0%87%E5%BF%97](vimages/1199509108971.jpg =404x)

偏移量，分包因为过大被分片时，第一片的偏移量为0，随后第二片的偏移量为片长度与序号-1的乘积。

ttl:
![0013%E7%BD%91%E7%BB%9C%E5%B1%82ttl%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4](vimages/4459655117004.jpg =526x)

ttl的存在是为了解决循环路由的问题，当路由a的默认路由是b,b的默认路由是a,而要发送的数据包a,b路由都不知道下一跳是哪时，a会走默认路由，到b ,
b发现也不知道下一跳，走默认路由a，如此a,b在踢皮球，导致资源占用和浪费，而有ttl的存在，在踢了一定次数后，这个包会被丢掉，并返回错误信息。

可以通过tracert, pathing等命令工具，查看通过的每个路由

### 传输层
传输层的协议主要有两个：
![0014%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE](vimages/2512452199674.jpg =508x)

udp:
![0015%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE__udp](vimages/4497956196229.jpg =549x)
这里的udp长度指的是首部和数据一起的长度，而不仅仅是首部的长度

检验和
![0016%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE__udp%E6%A3%80%E9%AA%8C%E5%92%8C](vimages/4129717219863.jpg =548x)

伪首部只用于计算，而并不真实存在。

端口
![0017%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE__%E7%AB%AF%E5%8F%A3](vimages/4976131224969.jpg =681x)