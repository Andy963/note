## 06_es6

### let 变量声明
```js
// 声明变量：
let a;
let b,c,d;
let e=100;
let f=521,g='iloveyou',h=[];
//1.变量不能重复声明，但var是可以的，防止变量重复，被污染

//2.块级作用域，全局，函数，eval
{
    var girl='girl';
}
console.log(girl);
// 上面的代码如果使用let是会出错，let的作用域只在块

//3. 不存在变量提升: 代码在执行之前会先收集变量
console.log(song);
var song = 'song'
// 这两行代码不会报错，只会报undefined,但如果使用let则会出错

//4.不影响作用域链
{
    let school = "school";
    function fn(){
        console.log(school);
    }
    fn();
    // fn函数中没有school,所以会向上一级查找
}
```

### const 常量声明
```js
// 声明
const SCHOOL = 'school'

//1.一定要赋初始值
//2.一般常量用大写
//3.常量的值不能修改
//4.块级作用域
{
    const PL='pl';
}
console.log(PL); // 会报错
//5.对数组和对象元素的修改，不算对常量的修改，因为常量的对象地址没变，与python中的可变类型变量引用一个道理
const NAME = ['a','b']
NAME.push('c')
// 上面两行代码没有问题
```

### 反引号
```js
// 声明 
let str = `这是个字符串`
//1.字符串中可以换行，原来的单引号只能用+拼接
let str = `str1
           str2
         `
console.log(str)
// 输出的也是换行
//2.变量拼接，原来用+
let name = 'zhou'
console.log(`hello ${name}`)
```

### 在大括号里面直接申明变量和函数作为属性和方法
```js
let name = 'zhou';
let change = function(){
    console.log(`${name},you can change yourself`);
}
const ZHOU = function(){
    name,
    change
}
// 上面大括号里面的完整写法是：name:name,change:change,现在可以简写
// 在上面的基本上再改：
const ZHOU = function(){
    name,
    change,
    improve:function(){
        console.log('only u can improve you');
    }
}
// 简化时可以将“：funciont”省略掉，对，没错，vue中就是这么做的
//简化后的版本：
const ZHOU = function(){
    name,
    change,
    improve(){
        console.log('only u can improve you');
    }
}
```

### 箭头函数
```js
//定义
//原来的定义
let fn = function(){
    
}
//新的定义
let fn=(a,b) =>{
    return a + b;
}

//1.this 是静态的，this始终指向函数声明时所在作用域下的this的值，没有自己的this.原来是谁调用this就是谁（即实例）
function getName(){
    console.log(this.name);
}

let getName2 = () =>{
    console.log(this.name);
}
// 设置window对象的name
window.name = 'zhou';
const SCHOOL = {
    name:"ZHOU"
}
// 直接调用
getName();
getName2();
//这种情况下，两者都指向window,即都打印出zhou
// call 调用
getName.call(SCHOOL);
getName2.call(SCHOOL);
// 上面的代码第一个是打印出:"ZHOU", 而第二个打印出:'zhou', 为什么会这样呢？因为在定义时getName2的this就已经确定了是window对象，
//而对于getName，因为传入了SCHOOL,所以this改变了

//2.不能作为构造实例化对象
let Person = (name,age) =>{
    this.name = name;
    this.age = age;
}
let me = new Person('zhou',30);
console.log(me);
//上面的代码会报错

//3.不能使用arguments变量
let fn = () => {
    console.log(arguments);
}
fn(1,2,3); // 未定义

//4.箭头函数的简写
  //1）省略小括号，当形参有且只有一个的时候
  let add = (n) =>{
    retun n+n;
  }
  // 上面代码可以省略如下：
  let add = n => {
    return n+n;
  }
  // 但上面这样其实不方便阅读，可能是我还没习惯吧
  //2）省略花括号，当代码只有一条语句时，此时return 必须省略
  let pow = (n) =>{
    return n * n ;
  }
  // 可以省略如下：因为只有一个形参，先省略括号，又因为只有一条语句，大括号也可以省略，然后再省略return 就成了下面的样子
  // 刚开始没习惯的时候非常不好阅读
  let pow = n => n * n 
```
箭头函数适合与this无关的回调，定时器，数组的方法回调
箭头函数不适合与this有关的回调，事件回调，对象的方法