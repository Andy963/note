### 导入（import）

```js
//1 直接编写,就将其放在html的<head>标签内 
<script> 
    alert('hello world') # alert（）实际为window.alert() 
</script> 
//2 导入文件 
<script src="hello.js"></script> 
<script language="javascript" type="text/javascript"></script> 
```

### 变量（variable）
js中var 定义的变量没法通过{}锁定作用域，而let是块级作用域。

#### var

```js
//1、声明变量时不用声明变量类型. 可以使用var,let关键字; 
var a; 
a=3; 

//2、一行可以声明多个变量.并且可以是不同类型 
var name="andy", age=20, job="geologist"; 

// 3、声明变量时,如果没有使用var 那么它是全局变量 

//#4、变量命名,首字符只能是字母,下划线,$美元符 三选一，余下的字符可以是下划线、美元符号或任何字母或数字字符且区分大小写，x与X是两个变量. 
```

#### let

let 声明的变量只在 let 命令所在的代码块 **{}** 内有效，在 **{}** 之外不能访问。

```go
{ 
    let x = 2;
}
```
#### constant

常量 ：直接在程序中出现的数据值 
标识符： 
- 由不以数字开头的字母、数字、下划线(_)、美元符号($)组成 
- 常用于表示函数、变量等的名称 
- 例如：_abc,$abc,abc,abc123是标识符，而1abc不是 
- JavaScript语言中代表特定含义的词称为保留字，不允许程序再定义为标识符 


### 字符串（string)

是由Unicode字符、数字、标点符号组成的序列；字符串常量首尾由单引号或双引号括起；JavaScript中没有字符类型；常用特殊字符在字符串中的表达；字符串中部分特殊字符必须加上右划线\；常用的转义字符 \n:换行 \':单引号 \":双引号 \\:右划线

```js
 let surname = 'zhou'
 let name = "jin"
 var firstName = new String("Bill")
``` 

定义时单双引号都可以，也可以在字符串中使用引号，只要不与最外层产生冲突就和地，这点上与python一致。

特殊字符串需要转义
\'	'	单引号
\"	"	双引号
\\	\	反斜杠

x = 'zhou', y = new String('zhou') 是<strong>不完全相等的</strong>，它们是不同类型，前者为字符串，后者为对象

x.length         －－－－获取字符串的长度 
x.toLowerCase()        －－－－转为小写 
x.toUpperCase()        －－－－转为大写 
x.trim()               －－－－去除字符串两边空格
x.charAt(index)       －－－－获取指定位置字符，其中index为要获取的字符索引 
x.charCodeAt(index)       -------返回指定索引位置的unicode的值 
x.fromCharCode()                   ------将unicode转换成字符串 
x.localcompare(y)           ----------用本地特定的顺序来比较两个字符串 
x.indexOf(findstr,index) －－－－查询字符串位置 
x.match(regexp)         －－－－match返回匹配字符串的数组，如果没有匹配则返回null 
x.search(regexp)        －－－－search返回匹配字符串的首字符位置索引 
x.substr(start, length) －－－－start表示开始位置，length表示截取长度 
x.substring(start, end) －－－－end是结束位置 
x.slice(start, end) －－－－切片操作字符串， 与python类似，左包右不包

反转字符串: 利用数组的reverse方法
```js
function reverseString(str) {
    return str.split("").reverse().join("");
}
reverseString("hello");
#ref:https://leetcode-cn.com/problems/palindrome-number/submissions/
```

##### indexOf()

indexof方法返回字符串中指定文本首次出现的索引位置

```js
let names = 'zhou wu zheng '
console.log(names.indexOf('z'));
console.log(names.lastIndexOf('z'));

```

当未找到指定文本时，两者均返回-1
通常我们判断字符串中是否有某个字符会通过索引是否为-1,但其实，我们也可以通`includes`

```js
let name = 'zhou abc'
console.log(name.includes('zh'))
// true
```

#### match

#### search() 

search方法搜索特定值的字符串，并返回匹配的位置

```js
let names = 'zhou wu zheng '
console.log(names.search('u')); // 3
```

search 可以使用正则

```js
let name = 'zhou abc '
reg = new RegExp('ab')
reg.test(name)
//true
```

##### slice

```js
var str = "Apple, Banana, Mango";
var res = str.slice(7,13);
```

如果某个参数为负，则从字符串的结尾开始计数。
如果省略第二个参数，则该方法将裁剪字符串的剩余部分

##### substring
substring方法与slice 类似，但它不能接受负数作为索引


##### substr() depricate
substr与slice 类似，但第二个参数规定提取字符串的长度
```js
let names = 'zhou wu zheng '
console.log(names.substr(3,4));
//u wu 
```
当忽略第二个参数时，会取第一个参数位置之后所有的字符
当第一个参数 为负，则从结尾开始取

##### replace
```js
str = "Please visit Microsoft!";
var n = str.replace("Microsoft", "W3School");
```
默认情况下，replace 只替换第一个匹配的，且默认情况区分大小写
使用正则的i，使其对大小写不敏感
```js
str = "Please visit Microsoft!";
var n = str.replace(/MICROSOFT/i, "W3School");
```
使用正则的g,使其替换所有
```js
str = "Please visit Microsoft and Microsoft!";
var n = str.replace(/Microsoft/g, "W3School");
console.log(n);
//Please visit W3School and W3School!
```

##### toUpperCase()/toLowerCase()

```js
var text1 = "Hello World!";       // 字符串
var text2 = text1.toUpperCase();  // text2 是被转换为大写的 text1
var text1 = "Hello World!";       // 字符串
var text2 = text1.toLowerCase();  // text2 是被转换为小写的 text1
```
##### concat()

连接两个或者多个字符串
```js
var text1 = "Hello";
var text2 = "World";
text3 = text1.concat(" ",text2);
```
##### String.trim()

去掉两边的空格

```js
var str = "       Hello World!        ";
console.log(str.trim());
```

##### charAt()

返回字符串中指定下标（位置）的字符串
```js
var str = "HELLO WORLD";
str.charAt(0);            // 返回 H
```
##### charCodeAt()

返回字符串中指定索引的字符 unicode 编码
```js
var str = "HELLO WORLD";
str.charCodeAt(0);         // 返回 72
```
##### Property Access

属性访问
```js
var str = "HELLO WORLD";
str[0];                   // 返回 H
```

它让字符串看起来像是数组（其实并不是）
如果找不到字符，[ ] 返回 undefined，而 charAt() 返回空字符串。
它是只读的。<u>**str[0] = "A" 不会产生错误（但也不会工作！）**</u>

##### split

将字符串转换成数组

```js
var txt = "a,b,c,d,e";   // 字符串
console.log(txt.split(","));          // 用逗号分隔
console.log(txt.split(" "));          // 用空格分隔
console.log(txt.split("|"));          // 用竖线分隔

[ 'a', 'b', 'c', 'd', 'e' ]
[ 'a,b,c,d,e' ]
[ 'a,b,c,d,e' ]
```

当用于分割的字符不存在时，则将字符串作为整体放在数组中。这与省略分割符相同，这与python语言中不同，python中默认使用空格
当分割符为“”时，返回是间隔单个字符的数组

```js
var txt = "a,b,c,d,e";   // 字符串
console.log(txt.split(""));          // 用逗号分隔
[
  'a', ',', 'b',
  ',', 'c', ',',
  'd', ',', 'e'
]
```

##### string2Number

there is a trick that we can convert a string num to real number: `"90" -0` it will convert `"90"` to `90`

```js
let a = parseInt('90')
typeof(a) // number

// 浮点数据则是使用parseFloat
// 与之类似的还有Number

typeof(Number('90')) // number
```

##### format
字符串格式化通常有两种方式，用+，以及ES6中的反引号
```js
var name = 'andy'
var s0 = 'hello ' + name
var s = `Hello ${name}`
console.log(s)
```



#### 数字（number）

不区分整型数值和浮点型数值; 所有数字都采用64位浮点格式存储，相当于Java和C语言中的double格式.能表示的最大值是±1.7976931348623157 x 10308,能表示的最小值是±5 x 10 -324 
整数： 
   在JavaScript中10进制的整数由数字的序列组成 
   精确表达的范围是 -9007199254740992 (-253) 到 9007199254740992 (253) 
   超出范围的整数，精确度将受影响 

浮点数： 
   使用小数点记录数据 
   例如：3.4，5.6 
   使用指数记录数据 
   例如：4.3e23 = 4.3 x 1023 
   
16进制和8进制数的表达: 
   16进制数据前面加上0x，16进制数是由0-9,A-F等16个字符组成;
   八进制前面加0;8进制数 由0-7等8个数字组成 
   16进制和8进制与2进制的换算: 
   2进制: 1111 0011 1101 0100   <-----> 16进制:0xF3D4 <-----> 10进制:62420 
   2进制: 1 111 001 111 010 100 <-----> 8进制:0171724 

#### 布尔（Boolean）

Boolean类型仅有两个值：true和false，也代表1和0，实际运算中true=1,false=0.布尔值也可以看作on/off、yes/no、1/0对应true/false.Boolean值主要用于JavaScript的控制语句，例如： 

```js
if (x==1){ 
      y=y+1; 
}else{ 
      y=y-1; 
      } 
```


### 数组（Array）
 js中数组的特性 
- js中的数组可以装任意类型,没有任何限制. 
- js中的数组,长度是随着下标变化的.用到多长就有多长.

```js
//创建方式1: 
var arrname = [元素0,元素1,….];          // var arr=[1,2,3]; 
//创建方式2: 
var arrname = new Array(元素0,元素1,….); // var test=new Array(100,"a",true); 
//创建方式3: 
var arrname = new Array(长度);  
//  初始化数组对象: 
    var cnweek=new Array(7); 
    cnweek[0]="星期日"; 
    cnweek[1]="星期一";  
    cnweek[6]="星期六"; 
```

two demension array

```js
var cnweek=new Array(7); 
for (var i=0;i<=6;i++){ 
    cnweek[i]=new Array(2); 
} 
cnweek[0][0]="星期日"; 
cnweek[0][1]="Sunday"; 
cnweek[1][0]="星期一"; 
cnweek[1][1]="Monday"; 
... 
cnweek[6][0]="星期六"; 
cnweek[6][1]="Saturday"; 
```

attr && method

#### join

```js
var arr1=[1, 2, 3, 4, 5, 6, 7]; 
var str1=arr1.join("-"); 
alert(str1);  //结果为"1-2-3-4-5-6-7"  
```

#### concat 

```js
x.concat(value,...)    －－－－  
var a = [1,2,3]; 
var b=a.concat(4,5) ; 
alert(a.toString());  //返回结果为1,2,3             
alert(b.toString());  //返回结果为1,2,3,4,5,相当于+ 
```

#### copyWithin

copyWithin(targetIndex, startIndex,endIndex )

```js

const fruits = ["Banana", "Orange", "Apple", "Mango", "Kiwi"];
fruits.copyWithin(2, 0, 2);
// 结果：["Banana", "Orange", "Banana", "Orange", "Kiwi"]


const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.copyWithin(2, 0);
// 结果：["Banana", "Orange", "Banana", "Orange"]

let evenNumbers= [2,4,6,8];
evenNumbers.copyWithin(-1);
// 结果：[2, 4, 6, 2]
```

它的一种应用场景是原地修改数组的元素

#### entries
返回数组的可迭代对象,该对象包含数组中每个索引的键值对

```js
const arr = ['a', 'b', 'c'];

const iterator = arr.entries();

for (let e of iterator) {
  console.log(e);
}

// [0, 'a']
// [1, 'b'] 
// [2, 'c']

```

entries()方法的常见应用场景包括:

1. 遍历数组时获取每个元素的索引。
2. 将数组转化为Map。例如:

```js
const map = new Map(arr.entries()); 
```

3. 遍历对象属性时获取键名。例如:

```js
const obj = { foo: 'bar' }; 

for (let [key, value] of Object.entries(obj)) {
  console.log(key, value);
}

// 'foo' 'bar'
```

entries与python中的enumerate[[004_函数与类#enumerate]]有相似之处，也有不同之处。
entries在获取迭代器时会立即计算所有值，且不接受任何参数，无法指定起始索引值。

#### every

用于数组中的所有元素是否都满足某个测试函数

```js
const numbers = [12, 25, 18, 130, 44];
const isAllNumbersGreaterThan10 = numbers.every(num => num > 10);
console.log(isAllNumbersGreaterThan10); // 输出：true
```

常见使用场景：
- 检查数组所有元素是否都满足某个条件
- 判断数组是具有某个统一的格式或者结构

python中有类似的all() [[004_函数与类#all]]方法，两者都可以判断可迭代对象的所有元素是否都计算为True
但 every 仅可用于数组，但all可用于任意可迭代对象，every,all 都会找到第一个false就短路返回，

#### fill

```js
const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.fill("Kiwi");
// 结果：["Kiwi", "Kiwi", "Kiwi", "Kiwi"]

arr = new Array(8).fill(false)
//arr [false, false, false,false, false, false,false, false ]

const fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.fill("Kiwi", 2, 4);
// 结果：["Banana", "Orange", "Kiwi", "Kiwi"]

```

#### filter

```js
let arr = [56, 15, 48, 3, 7];
let newArr = arr.filter(function (value, index, array) {
    return value % 2 === 0;
});
console.log(newArr)

// 去除空值
let  newrr = ['','',1,2,3]
var newArr = newrr.filter(item => item)
console.log(newArr)
//[1,2,3]  因为'' 被认为为false 的值
```

#### find

find 返回符合传入函数条件的第一个数组元素

```js
arr = [1, 2, 3, 4, 5]
let result = arr.find(item => item > 3);
console.log(result);  // 输出：4
```

注意它是只返回符合条件的第一个元素，而filter会返回所有元素

#### findIndex
返回符合传入数组条件的数组第一个元素的索引，如果没有返回-1

#### forEach

数组中每个元素都执行一次回调函数, 函数有三个参数

```js
array.forEach(callbackFn(currentValue, index, arr), thisValue)
- currentValue - 数组中当前被处理的元素
- index - 当前元素的索引
- arr - 数组本身
```

通常情况下，只会用到第一个参数：

```js
const numbers = [1, 2, 3, 4];

let sum = 0;
numbers.forEach(function(n) {
  sum += n; 
});

console.log(sum); // 10
```

#### from

from 从一个类数组或可迭代对象创建一个新的浅拷贝的数组实例 `Array.from(arrayLike, mapFn, thisArg)` 
- arrayLike - 想要转换成数组的类数组对象或可迭代对象。
- mapFn - 可选,新数组中的每个元素会执行该回调函数。
- thisArg - 可选,执行回调函数 mapFn 时 this 对象。

```js
var myArr = Array.from('RUNOOB');
console.log(myArr);  // 输出：[ 'R', 'U', 'N', 'O', 'O', 'B' ]

var arr = Array.from([1, 2, 3], x => x * 10);
console.log(arr);  // 输出：[10, 20, 30]

```

#### includes

判断一个数组是否包含一个指定的值，如果是返回true,否则 返回false

```js
[1, 2, 3].includes(2); // 返回 true
[1, 2, 3].includes(4); // 返回 false
```

#### indexOf

搜索数组中元素，返回它所在的位置。它与findIndex的区别是： indexOf 用于查找 数组中特定的元素，而findIndex则接收一个函数作为参数。但如果不存在的元素，两者都会返回-1

```js
let arr = [1, 2, 3, 4, 5];
console.log(arr.indexOf(3));  // 输出：2

```

#### isArray

isarray用于确定传递的数值是否是一个数组，它不检查原型链，也不依赖于它所附加的构造函数，对于使用数组字面量语法或者Array构造函数创建的值，它都返回true

```js
console.log(Array.isArray([1, 2, 3]));  // 输出：true
console.log(Array.isArray('Runoob'));  // 输出：false
```

下面内容来自claude2 未验证

```js
- instanceof 可以判断对象的类型,但可能由于多窗口而失败
- Array.isArray() 只检测数组,但不会失败

所以 Array.isArray() 是更可靠地判断数组的方法。

注意,它在存在 iframes 的情况下也可以正常工作,而 instanceof 会失败。

例如:


let iframe = document.createElement('iframe');
document.body.appendChild(iframe);
let iArray = window.frames[window.frames.length-1].Array;

let arr = [1, 2, 3]; 

// 在 iframe 中创建的数组
console.log(arr instanceof iArray); // false  

// 正确的方法  
console.log(Array.isArray(arr)); // true
```

主要用于数据类型检查，避免出现错误。

#### join

Array.join(sep)

```js
let fruits = ['apple', 'banana', 'cherry'];
let result = fruits.join(); // 默认使用逗号作为分隔符
console.log(result); // 输出 "apple,banana,cherry"
```

功能上它与Python中字符串的join[[002_数据运算与类型#join]]是一样的，但区别是python中是字符串内建方法

#### keys

返回数组每个索引的迭代对象

```js
let fruits = ['apple', 'banana', 'cherry'];
let keys = fruits.keys();

for (let key of keys) {
  console.log(key); // 输出 "0", "1", "2"
}
```

它与[[002_Object#entries]] 的不同之处在于，它只返回索引，而entries会返回索引和值

#### lastIndexOf

它用于从数组的末尾开始向前查找指定元素，并返回它的索引。如果没有找到元素，则返回-1

` array.lastIndexOf(item, start) `  `item`是必需的，指定要搜索的元素。`start`是可选的，指定从哪个位置开始搜索

```js
let fruits = ['apple', 'banana', 'cherry', 'apple', 'banana'];
let index = fruits.lastIndexOf('apple'); 
console.log(index); // 输出 "3"
```

lastIndexOf 类似python中字符串的 rindex方法[[002_数据运算与类型#rindex]]

#### map

`map()`方法是数组的一个内置方法，它创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果 `array.map(function(currentValue, index, arr), thisValue)
`
```js
let numbers = [1, 2, 3, 4];
let squares = numbers.map(x => x * x);
console.log(squares); // 输出 "[1, 4, 9, 16]"
```

它与forEach的不同在于：forEach不会返回一个新的数组,而python中map[[004_函数与类#map]] 是 一个内建函数
#### reverse/sort

array sort并不是按数字大小，而是ascii
```js
var arr1=[32, 12, 111, 444]; 
arr1.sort() // [111, 12, 32, 444]
arr1.reverse //[444, 32, 12, 111]
```
sort(func)中可以传入一个函数来决定排序规则
```js
function intSort(a,b){ 
    if (a>b){ 
        return 1;//-1 
    } 
    else if(a<b){ 
        return -1;//1 
    } 
    else { 
        return 0 
    } 
} 

arr.sort(intSort); 
alert(arr); 
```

#### slice /splice
x.slice(start, end) 
start表示开始位置索引 end是结束位置下一数组元素索引编号 
//第一个数组元素索引为0 
//start、end可为负数，-1代表最后一个数组元素 
//end省略则相当于从start位置截取以后所有数组元素

```js
let fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];
let someFruits = fruits.slice(1, 3);
console.log(someFruits); // 输出 ["banana", "cherry"]
```

x. splice(start, deleteCount, value, ...) 
splice的主要用途是对数组指定位置进行删除和插入 start表示开始位置索引 deleteCount删除数组元素的个数 value表示在删除位置插入的数组元素 value参数可以省略  

```js
a = ['a','b','c']
(3) ['a', 'b', 'c']
a.splice(1,0,'d') // 从索引为1的位置开始删除，删除0个，并用'd'来替换
[]
a 
(4) ['a', 'd', 'b', 'c']
// 第三个元素是要添加的元素
```

#### push/pop
数组的push和pop： 
push pop这两个方法模拟的是一个栈操作 x.push(value, ...)  压栈 x.pop()弹栈       
value可以为字符串、数字、数组等任何值 push是将value值添加到数组x的结尾 pop是将数组x的最后一个元素删除 

push 返回新数组的长度， pop返回删除的那个元素

```js
let fruits = ['apple', 'banana'];
let newLength = fruits.push('cherry');
console.log(fruits); // 输出 ["apple", "banana", "cherry"]
console.log(newLength); // 输出 3

let fruits = ['apple', 'banana', 'cherry'];
let lastFruit = fruits.pop();
console.log(fruits); // 输出 ["apple", "banana"]
console.log(lastFruit); // 输出 "cherry"
```

#### shift/unshift
x.unshift(value,...) x.shift() 
value可以为字符串、数字、数组等任何值 unshift是将value值插入到数组x的开始位置 shift是将数组x的第一个元素删除

unshift 会返回新数组的长度， shift 删除数组的第一个元素

```js
let fruits = ['banana', 'cherry'];
let newLength = fruits.unshift('apple');
console.log(fruits); // 输出 ["apple", "banana", "cherry"]
console.log(newLength); // 输出 3

let fruits = ['apple', 'banana', 'cherry'];
let firstFruit = fruits.shift();
console.log(fruits); // 输出 ["banana", "cherry"]
console.log(firstFruit); // 输出 "apple"
```

#### reduce


```js
let numbers = [1, 2, 3, 4];
let sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // 输出 "10"
```

#### reduceRight

`reduceRight()`方法与`reduce()`方法类似，但它是从数组的末尾开始向前应用函数，而不是从开始处

#### some

查看是否有满足条件的元素，是则返回true, 否则 返回false

```js
array.some(function(currentValue, index, arr), thisValue)
let numbers = [1, 2, 3, 4];
let hasNegativeNumbers = numbers.some(num => num < 0);
console.log(hasNegativeNumbers); // 输出 "false"

```
#### toString

将数组转化成字符串,注意，它把逗号也带上了

```js
let fruits = ['apple', 'banana', 'cherry'];
let str = fruits.toString();
console.log(str); // 输出 "apple,banana,cherry"
```

#### valueOf

获取数组的原始值

```js
let numbers = [1, 2, 3, 4];
let originalValue = numbers.valueOf(); // [1, 2, 3, 4]
let stringValue = numbers.toString(); // "1,2,3,4"
let sum = numbers.reduce((total, num) => total + num, 0); // 10
```

#### Array 解构

```js
let [a,b,c] = ['1',2,3] // 声明同时解构
;[d,c,e,f=10] = [1,3,5] // 前边加";"告诉后面是一个独立的句子，并且f设置了默认值
【g,h,i=i] = [1,2] // i如有有赋新值，则使用新值，如果没有赋值则使用原来的值。
```
#### 合并两个数组并同时去重
经常会有这种需求，比如在页面进行勾选时，有时需要与已经勾选的列表进行合并（某些情况下勾选一个会添加多个子项），此时就存在合并的情况，以前我都是通过循环，判断的方式
在ES6中可以使用下面的方法进行：

```js
a = [1,2,3]
b = [2,3,4]
d = Array.from(new Set([...a,...b]))
(4) [1, 2, 3, 4]
```

其实就是通过set去重，然后将set转成array

#### null/undefined

Null 与undefined类型： 
- Undefined类型:Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。当函数无明确返回值时，返回的也是值 "undefined"; 
- Null类型:另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。 

尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。 

#### NaN

NaN:属于Number类型的一个特殊值,当遇到将字符串转成数字无效时,就会得到一个NaN数据

```js
var d="andy"; 
d=+d; 
alert(d);//NaN
alert(typeof(d));//Number 
```
//NaN特点:
```js
var n=NaN; 
alert(n>3); 
alert(n<3); 
alert(n==3); 
alert(n==NaN); 
alert(n!=NaN); 
```

//NaN参与的所有的运算都是false,除了!= 

### operator

 ` +   -    *    /     %       ++        --`
  
比较运算符：

    >   >=   <    <=    !=    ==    ===   !== 

逻辑运算符：与，或，非 

     &&   ||   ！

赋值运算符： 

    =  +=   -=  *=   /= 

字符串运算符： 
    +  连接，两边操作数有一个或两个是字符串就做连接运算 

注意1: 自加自减 
假如x=2，那么x++表达式执行后的值为3，x--表达式执行后的值为1；i++相当于i=i+1，i--相当于i=i-1；
递增和递减运算符可以放在变量前也可以放在变量后：--i 

### compare

```
 >   >=   <    <=    !=    ==    ===   !==
```

用于控制语句时

```js
if (2>1){       //  3  0  false null undefined ［］ 
    console.log("条件成立!") 
}
```

等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 
```js
console.log(2==2); 
console.log(2=="2"); 
console.log(2==="2"); 
console.log(2!=="2"); 
```

### alert

```js
var bResult = "Blue" < "alpha"; 
alert(bResult); //输出 true 
```
在上面的例子中，字符串 "Blue" 小于 "alpha"，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。比较数字和字符串 

另一种棘手的状况发生在比较两个字符串形式的数字时，比如： 
```js
var bResult = "25" < "3"; 
alert(bResult); //输出 "true" 
```
上面这段代码比较的是字符串 "25" 和 "3"。两个运算数都是字符串，所以比较的是它们的字符代码（"2" 的字符代码是 50，"3" 的字符代码是 51）。 
不过，如果把某个运算数改为数字，那么结果就有趣了：

```js
var bResult = "25" < 3; 
alert(bResult); //输出 "false" 
```

这里，字符串 "25" 将被转换成数字 25，然后与数字 3 进行比较，结果不出所料。 
总结： 
> 比较运算符两侧如果一个是数字类型,一个是其他类型,会将其类型转换成数字类型. 
> 比较运算符两侧如果都是字符串类型,比较的是最高位的asc码,如果最高位相等,继续取第二位比较. 

等性运算符：执行类型转换的规则如下： 
> 如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。  
> 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。  
> 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。  
> 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。  
在比较时，该运算符还遵守下列规则： 
>值 null 和 undefined 相等。  
> 在检查相等性时，不能把 null 和 undefined 转换成其他值。  
> 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。  
> 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。

### control flow

#### order
```js
<script> 
console.log(“星期一”); 
console.log(“星期二”); 
console.log(“星期三”); 
</script> 
```

#### condition

^376bba

三目运算：
console.log(2>1?2:1) 如果前面条件成立返回问号后面的值  如果条件不成立,返回冒号后的

对于Python, golang 中都没有三目运算，而是采用 `if else` 语句

```js
if (表达式){ 
   语句１; 
   ...... 
   } else{ 
   语句２; 
   ..... 
   } 
)

var score=window.prompt("您的分数:"); 
if (score>90){ 
    ret="优秀"; 
}else if (score>80){ 
    ret="良"; 
}else if (score>60){ 
    ret="及格"; 
}else { 
    ret = "不及格"; 
}

switch(x){ 
    case 1:y="星期一";    break; 
    case 2:y="星期二";    break; 
    case 3:y="星期三";    break; 
    case 4:y="星期四";    break; 
    case 5:y="星期五";    break; 
    case 6:y="星期六";    break; 
    case 7:y="星期日";    break; 
    default: y="未定义"; 
} 
```
#### loop

```js
var i=1; 
while (i<=7) { 
    document.write("<H"+i+">hello</H "+i+"> "); 
    document.write("<br>"); 
    i++; 
}
```

### exception

```js
try { 
    //这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行 
} 
catch (e) { 
    // 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。 
    //e是一个局部变量，用来指向Error对象或者其他抛出的对象 
} 
finally { 
     //无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。 
} 
//注：主动抛出异常 throw Error('xxxx') 
```

js中异常处理与python 类似， python[[006_错误与异常#05_错误与异常]]中使用 try , except, finally, 而对于go中[[04_流程控制#exception]],则有更多不同，因为go中异常是作为返回值。
### output

```js
//这里的输出类似于python的print,意思是输出数据，方便编程时查看： 

//方式一： 
window.alert("a");//这里window可以省略不写 

//方式二： 
window.write("b"); 

方式三： 
innerHTML//写入到HTML元素 

方式四： 
console.log()// 输出到浏览器控制台  
```