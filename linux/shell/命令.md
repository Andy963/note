

### ln
`ln [-s] 源文件  目标文件`
硬链接相当于给文件找了另一个入口（比如超市有前后门），通过每个入口都可以访问到文件内容。只删除其中一个入口，文件实体并不会删除。只有当所有入口都删除后，文件才会被删除。可以通过这种方式防止重要文件被删除。

ln -s source destionation 创建软链接时，destionation不能已经存在了。

对于目录而言，不能创建硬链接，但可以创建软链接。

通常情况下，我们查看软链接的内容时，只能看到源文件的内容，而无法看到软链接的真实内容。此时需要使用readlink命令。
```shell
 /opt  cat soft_link
123
 /opt  readlink soft_link
soft
```

### tail && tailf

tail 命令用于显示文件内容的尾部，默认为尾部10行
`tail options file`

options:
```
c    指定显示的字节数
n    指定显示的行数
f    实时输出文件追加的数据
F    == -f -retry
retry 不停尝试打开文件，直到打开为止与f合用
pid  与 -f合用，在进程结束后自动退出tail命令
s    监视文件内容变化的时间间隔
q    不显示包含给定文件名的文件头
v     始终显示给定文件的文件头
```

tailf命令类似于tail -f 但如果文件不增长，它不会访问磁盘文件，也不会修改文件的访问时间

### split && cut
按照指定行数或者文件大小分割文件
`split option input file prefix`

options:
```linux
b     指定分割后文件的最大字节数
l     指定分割后文件最大行数
a     指定后缀长度，默认为2位字母
d     使用数字后缀
```

cut 从文件的每一行剪切字节，字符或者字段.

### paste
默认情况下分隔符为tab,可通过-d指定分隔符，-s则会让每个文件占用一行，见下面示例
合并文件 `paste file1 file2`
```shell
 /mnt/d/code/vim_learn  cat a.txt
kkfsaf
zhou_andy
 /mnt/d/code/vim_learn  cat b.txt
1
2
 /mnt/d/code/vim_learn  paste b.txt a.txt
1       kkfsaf
2       zhou_andy

 /mnt/d/code/vim_learn  paste -d : b.txt a.txt
1:kkfsaf
2:zhou_andy
 /mnt/d/code/vim_learn  cat a.txt
kkfsaf
zhou_andy

 /mnt/d/code/vim_learn  paste -s a.txt
kkfsaf  zhou_andy
```

### sort
将输入的文件内容按照指定的文件规则进行排序，并将排序结果输出
参数：
- b 忽略自强街开头存在的空格字符
- u 去重
- n 按数值大小进行排序 
- t 指定分隔符
- r 倒序排列
- k 指定区间排序

```shell
 /mnt/d/code/vim_learn  cat a.txt
10.0.0.1
10.0.0.1
10.0.0.1
10.0.0.3
10.0.0.5
10.0.0.6
 /mnt/d/code/vim_learn  sort a.txt  # 默认按ascill码排序
10.0.0.1
10.0.0.1
10.0.0.1
10.0.0.3
10.0.0.5
10.0.0.6
 /mnt/d/code/vim_learn  sort -n a.txt  # 按数字大小排序
10.0.0.1
10.0.0.1
10.0.0.1
10.0.0.3
10.0.0.5
10.0.0.6
 /mnt/d/code/vim_learn  sort -r a.txt   # 倒序
10.0.0.6
10.0.0.5
10.0.0.3
10.0.0.1
10.0.0.1
10.0.0.1
 /mnt/d/code/vim_learn  sort -u a.txt   # 去重
10.0.0.1
10.0.0.3
10.0.0.5
10.0.0.6

 /mnt/d/code/vim_learn  cat a.txt  # 新的数据
a 10.0.0.1
c 10.0.0.1
b 10.0.0.4
d 10.0.0.3
e 10.0.0.5
g 10.0.0.6
 /mnt/d/code/vim_learn  sort a.txt  # 默认按第一列排序
a 10.0.0.1
b 10.0.0.4
c 10.0.0.1
d 10.0.0.3
e 10.0.0.5
g 10.0.0.6
 /mnt/d/code/vim_learn  sort -t ' ' -k2 a.txt  # -t指定按什么分隔，这里空格，所以有两列
a 10.0.0.1
c 10.0.0.1
d 10.0.0.3
b 10.0.0.4
e 10.0.0.5
g 10.0.0.6
```
### join
join按两个文件的相同字段合并
-a 指定文件号
-i 忽略大小写
```shell
 /mnt/d/code/vim_learn  cat a.txt
zhou 23岁
andy 29岁
 /mnt/d/code/vim_learn  vim b.txt
 /mnt/d/code/vim_learn  cat b.txt
zhou 男
andy 男
 /mnt/d/code/vim_learn  join a.txt b.txt
zhou 23岁 男
andy 29岁 男
 /mnt/d/code/vim_learn  cat a.txt
zhou 23岁
andy 29岁
 /mnt/d/code/vim_learn  cat b.txt
zhou 男
andy 男
```

### uniq
如果没排除，本身是隔开的，uniq仍会有重复行，见下面示例
-c 去除重复行，并显示出现的次数
-d 只显示重复的行
-u 只显示唯一的行
```shell
 /mnt/d/code/vim_learn  cat a.txt
zhou 23岁
zhou 23岁
andy 29岁
zhou 23岁
 /mnt/d/code/vim_learn  sort a.txt
andy 29岁
zhou 23岁
zhou 23岁
zhou 23岁
 /mnt/d/code/vim_learn  uniq a.txt
zhou 23岁
andy 29岁
zhou 23岁
 /mnt/d/code/vim_learn  sort a.txt|uniq
andy 29岁
zhou 23岁
```

### wc
统计文件的行数，单词数或者字节数
-c 统计字节数
-l 统计行数
-m 统计字符数
```shell
 /mnt/d/code/vim_learn  wc -c a.txt
44 a.txt
 /mnt/d/code/vim_learn  wc -l a.txt
4 a.txt
 /mnt/d/code/vim_learn  wc -m a.txt
36 a.txt
```

### iconv
转换文件的编码格式
-f encodingA 从编码A转换
-l 显示系统
-t encodingB 转换成编码B
-o 输出到指定文件
示例：
假若有文件是gb2312格式，其中有中文字符。在linux下的utf-8下会显示乱码，下面是处理方式：
`iconv -f gb2312 -t utf-8 gb2312.txt`

### dos2unix
将dos格式文件转换成unix格式
dos（win) 系统下换行符是'\r\n',而linux下则是‘\n', 所以在linux上运行dos系统脚本可能会出错，但直接查看代码可能检查不出错误，此时可以通过此命令转换。unix2dos是反向操作。
`dos2unix test.sh`

### diff
diff 逐行比较文件，并输出不同
-y 以并列的方式显示文件的异同
-c 使用上下文的输出格式
-W 在使用-y参数时指定显示宽度
-u 使用统一格式输出
```shell
 /mnt/d/code/vim_learn  cat a.txt
zhou 23岁
zhou 23岁
andy 29岁
zhou 23岁
 /mnt/d/code/vim_learn  cat b.txt
zhou 男
andy 男
 /mnt/d/code/vim_learn  diff a.txt b.txt
1,4c1,2
< zhou 23岁
< zhou 23岁
< andy 29岁
< zhou 23岁
---
> zhou 男
> andy 男
```
输出结果中参数说明
a -add 
c -change
d -delete

### vimdiff
调用vim打开文件，并用不同颜色来区分文件的不同。退出时要使用两次退出。

### rev
rev按行反向输出文件内容
```shell
 ~/Desktop  echo {1..10}
1 2 3 4 5 6 7 8 9 10
 ~/Desktop  echo {1..10} |rev
01 9 8 7 6 5 4 3 2 1
```

### tr
从标准输入中替换，缩减，删除字符，并将结果写到标准输出
-d 删除字符
-s 保留连续字符的第一个字符，删除其他字符
-c 使用第一个字符串的补集，取反
```shell
 ✘  ~/Desktop  cat code.py 


class A:
	def __enter__(self):
		a = 1

	def __exit__(self):
		b = 2

with A() as obj:
	print(obj)


 ~/Desktop  tr 'class' 'Module' < code.py              


Modll A:
	def __enter__(leof):
		d = 1

	def __exit__(leof):
		b = 2

with A() dl obj:
	print(obj)
```
大小写转换
```shell
 ~/Desktop  tr '[a-z]' '[A-Z]' < code.py 


CLASS A:
	DEF __ENTER__(SELF):
		A = 1

	DEF __EXIT__(SELF):
		B = 2

WITH A() AS OBJ:
	PRINT(OBJ)
```
删除字符
```shell
 ✘  ~/Desktop  tr -d 'A' < code.py


class :
	def __enter__(self):
		a = 1

	def __exit__(self):
		b = 2

with () as obj:
	print(obj)

```

删除文件中的换行，制表符
```shell
~/Desktop  tr -d '\n\t' < code.py
class A:def __enter__(self):a = 1def __exit__(self):b = 2with A() as obj:print(obj)%                                                                                                           
```

### od
od命令用于输出文件的八进制，十六进制或者其他格式的字节。目前没发现什么用处。

### tee
tee用于将数据重定向到文件，同时提供一份副本作为后续命令的标准输入
```shell
 ~/Desktop  cat code.py |tee code.copy


class A:
	def __enter__(self):
		a = 1

	def __exit__(self):
		b = 2

with A() as obj:
	print(obj)


 ~/Desktop  cat code.copy             


class A:
	def __enter__(self):
		a = 1

	def __exit__(self):
		b = 2

with A() as obj:
	print(obj)

```
### grep
从文件或者管道中筛选出需要的信息
-v 显示不匹配的行，或者说排除某些行，显示不包含匹配文本的所有行
-n 显示匹配行及行号
-i 不区分大小写 
-c 只统计匹配的行数
-E 使用扩展的egrep命令
--color=auto 为grep过滤的匹配字符串添加颜色
-w 只匹配过滤的单词
-o 只输出匹配的内容
```shell
 ~/Desktop  grep -n 'andy' /etc/passwd
41:andy:x:1000:0:andy,,,:/home/andy:/bin/zsh


 ⚡ root@VM  ~  grep -Ev "#|^$" /etc/nginx/conf/nginx.conf
user  root;
worker_processes  3;
pid         /etc/nginx/logs/nginx.pid;
events {
    worker_connections  4096;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
include conf.d/*.conf;
}

```