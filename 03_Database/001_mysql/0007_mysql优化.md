## 优化措施

### 使用连接池
对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能

### 减少对数据库的访问
1.避免重复检索
在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。
比如 ，需要获取书籍的id 和name字段 ， 则查询如下：
```SQL
select id , name from tb_book;
select id , status from tb_book;
```
这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。
```SQL
select id, name , status from tb_book;
```
2.缓存
在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。
因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存/二级缓存，或者使用redis数据库来缓存数据 。
3.负载均衡
负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果

4.评价复制分流查询
通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力

5.使用分页式数据库架构
分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率

[refs](https://blog.51cto.com/u_15127571/3575663): 

### SQL语句，表结构
使用索引，表结构设计得更合理一些，数据库设计三范式：
> 要有主键，且每个字段原子性不可再分
> 所有非主键字段完全依赖主键，不能产生部分依赖
> 所有非主键字段和主键字段之间不能产生传递依赖

[refs](https://www.jianshu.com/p/3e97c2a1687b)

mysql中char与varchar

1. 建表时定长数据往前放，变长数据往后放
2. 一张表中，定长，变长尽量不要混用

## MySQL的四大隔离级别，并解释他们

MySQL 支持四种事务隔离级别,从低到高分别是:

1. READ UNCOMMITTED (读未提交)

2. READ COMMITTED (读已提交)

3. REPEATABLE READ (可重复读)

4. SERIALIZABLE (串行化)

下面详细解释每个级别:

1. READ UNCOMMITTED (读未提交)

⦁ 最低的隔离级别
⦁ 一个事务可以读取另一个未提交事务的修改
⦁ 可能会产生脏读、不可重复读和幻读问题
⦁ 性能最好,但几乎不用于实际应用

例子:
事务A修改了一行数据但还未提交,事务B可以读到这个未提交的修改。

2. READ COMMITTED (读已提交)

⦁ 只能读取到已经提交的数据
⦁ 可以避免脏读
⦁ 但仍可能发生不可重复读和幻读
⦁ Oracle默认的隔离级别

例子:
事务A读取一行数据,事务B修改该行并提交,事务A再次读取时可以看到事务B的修改。

3. REPEATABLE READ (可重复读)

⦁ MySQL的默认隔离级别
⦁ 在同一事务中多次读取数据结果一致
⦁ 可以避免脏读和不可重复读
⦁ 但仍可能产生幻读
⦁ 使用MVCC (多版本并发控制)机制实现

例子:
事务A多次读取同一数据,在事务A执行期间,事务B对该数据进行了修改并提交,事务A之后的读取仍然返回开始时的数据。

4. SERIALIZABLE (串行化)

⦁ 最高的隔离级别
⦁ 完全串行化的读写,事务之间完全隔离
⦁ 可以避免脏读、不可重复读和幻读
⦁ 性能最差,并发度最低

例子:
事务A在操作某些行时,事务B对这些行的读写操作会被阻塞,直到事务A完成。

总结:

1. 隔离级别越高,数据一致性越好,但并发性能越差。
2. 大多数数据库默认级别是READ COMMITTED,MySQL默认是REPEATABLE READ。
3. 应根据应用的需求来权衡和选择合适的隔离级别。
4. 在实际应用中,READ COMMITTED和REPEATABLE READ使用较多。
