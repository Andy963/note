#!/usr/bin/env python
# -*- coding: utf-8 -*-
# @Date     : 2024/9/18
# @FileName : 04.py # noqa
# Created by; Andy963
"""
流浪地球计划在赤道上均匀部署了N个转向发动机,按位置顺序编号为O~N-1。

1、初始状态下所有的发动机都是未启动状态;
2、发动机起动的方式分为“手动启动"和“关联启动"两种方式;
3、如果在时刻1一个发动机被启动,下一个时刻2与之相邻的两个发动机就会被“关联启动”;
4、如果准备启动某个发动机时,它已经被启动了,则什么都不用做;
5、发动机0与发动机N-1是相邻;

地球联合政府准备挑选某些发动机在某些时刻进行”手动启动”,当然最终所有的发动机都会被启动。哪些发动机最晚被启动呢?
输入描述
第一行两个数字N和E,中间有空格
N代表部署发动机的总个数,E代表计划手动启动的发动机总个数1<N<=1000,1<=E<=1000,E<=N
接下来共E行,每行都是两个数字T和P,中间有空格
T代表发动机的手动启动时刻,P代表此发动机的位置编号。0<=T<=N,0<=P<=N

输出描述
第一行一个数字N,以回车结束N代表最后被启动的发动机个数
第二行N个数字,中间有空格,以回车结束每个数字代表发动机的位置编号,从小到大排序

示例1
输入
8 2
0 2
0 6
输出
2
0 4
说明：8个发动机,时刻0启动2和6号发动机
示例2
82
01
17
输出
1
4
说明：8个发动机,时刻0启动2和6号发动机

解题思路
这道题目要求我们模拟发动机的启动过程，找到最后被启动的发动机。发动机的启动方式包括手动启动和关联启动。
我们需要根据给定的手动启动时刻，计算所有发动机最终被启动的时刻，并找出最后被启动的那些发动机。

1. 初始化
- 发动机状态表示：我们用一个数组 activationTime 来记录每个发动机的启动时间，初始时所有发动机的启动时间都设置为 -1，表示未启动。
- 优先队列：我们使用一个优先队列来管理发动机的启动事件。优先队列根据启动时间排序，这样我们可以总是处理最早的启动事件。
2. 手动启动
- 输入处理：根据输入的手动启动事件 (T, P)，我们首先更新发动机 P 的启动时间为 T，如果它之前没有被启动过。
- 加入队列：将每个手动启动的发动机 (T, P) 加入优先队列。这里的 `T` 是启动时间，P 是发动机的位置。

3. 关联启动传播
处理队列中的事件：我们从优先队列中取出当前时间最早的启动事件 (time, pos)。
关联启动逻辑：
- 如果发动机 pos 在当前时间 time 启动，则在下一个时间 time + 1，它的相邻发动机 (pos - 1 + N) % N 和 (pos + 1) % N 将被关联启动（考虑环形结构，即 0 和 N-1 也是相邻的）。
- 检查每个相邻发动机，如果该发动机未启动过，或其启动时间可以更早，则更新其启动时间为 time + 1，并将其加入优先队列。
4. 找到最后启动的发动机
- 确定最后启动时间：在所有发动机的启动时间中，找出最大值，这个最大值就是最后启动的时间。
- 收集最后启动的发动机：遍历所有发动机，找出启动时间等于最大值的发动机，并将它们的编号记录下来。
5. 输出结果
输出最后启动的发动机数量：输出最后被启动的发动机的数量。
输出发动机编号：输出这些发动机的编号，并按升序排序。
算法复杂度
时间复杂度：由于每个发动机最多只会进入优先队列一次，且每次操作（插入和删除）在优先队列中的复杂度为 O(log N)，整体时间复杂度为 O(N log N)。
空间复杂度：使用了几个长度为 N 的数组和一个优先队列，因此空间复杂度为 O(N)。
"""

import heapq


def main():
    import sys
    input = sys.stdin.read
    data = input().splitlines()

    N, E = map(int, data[0].split())
    activation_time = [-1] * N  # 初始化每个发动机的启动时间为-1，表示未启动
    visited = [False] * N  # 布尔列表，判断发动机是否启动过

    # 优先队列（最小堆），按启动时间排序
    pq = []

    # 读取手动启动事件
    for i in range(1, E + 1):
        T, P = map(int, data[i].split())
        if activation_time[P] == -1:  # 如果发动机P未启动过
            activation_time[P] = T  # 更新发动机P的启动时间
            heapq.heappush(pq, (T, P))  # 将事件加入优先队列

    # 根据关联启动规则传播启动状态
    while pq:
        time, pos = heapq.heappop(pq)

        if visited[pos]:  # 如果已经处理过该发动机，跳过
            continue
        visited[pos] = True  # 标记发动机pos为已启动

        next_time = time + 1

        # 检查相邻的发动机（环形结构）
        neighbors = [(pos - 1 + N) % N, (pos + 1) % N]
        for neighbor in neighbors:
            if activation_time[neighbor] == -1 or activation_time[neighbor] > next_time:
                # 仅当相邻发动机未启动或者可以更早启动时，才更新其启动时间
                activation_time[neighbor] = next_time
                if not visited[neighbor]:  # 如果相邻发动机没启动过，才加入队列
                    heapq.heappush(pq, (next_time, neighbor))

    # 找出最后被启动的发动机
    max_time = max(activation_time)
    latest_engines = [i for i in range(N) if activation_time[i] == max_time]

    # 输出结果
    print(len(latest_engines))  # 输出最后被启动的发动机数量
    print(" ".join(map(str, latest_engines)))  # 输出发动机编号，按升序排序


if __name__ == "__main__":
    main()