## 指针

### memory address
```go
package main

import "fmt"

func main()  {
	a := 10
	fmt.Printf("a=%d\n",a)
	fmt.Printf("a 的地址是:%v\n", &a)
}
```
### 操作指针指向的内存
```go
package main

import "fmt"

func main() {
	a := 10
	fmt.Printf("a=%d\n", a)
	fmt.Printf("a 的地址是:%v\n", &a)

	// 保存某个变量的地址，需要指针类型 *int保存int的地址， **int 保存 *int的地址
	// 定义一个变量p,类型为×int
	var p *int
	p = &a // p的值为a变量的内在地址
	fmt.Printf("p=%v, &=a=%v\n", p, &a)

	*p = 666 // *p 表示p变量所指向的内存，对它赋值，即修改了指向该地址的变量
	fmt.Printf("*p=%v, a=%v\n", *p, a)
}
```

### 不要操作没有合法指向的内存地址
```go
package main

import "fmt"

func main()  {
	var p *int
	fmt.Println("p=",p) // p 指向空
	// 不要操作没有合法指向的内存地址
	//*p = 666
}
```

### new
```go
package main

import "fmt"

func main() {
	a := 10
	var p *int

	p = &a // p指向一个合法内存

	//p 是*int, 指向int顾炎武
	p = new(int)

	*p = 666
	fmt.Println("*p=", *p)
}
```
new 动态的分配了内存给*p.只管用，不需要考虑释放内存地址的问题

### swap
```go
package main

import "fmt"

func swap(a, b int) {
	a, b = b, a
	fmt.Println("a=,b=", a, b)
}

func main() {
	a, b := 10, 20
	swap(a, b)
	fmt.Println("main:a=,b=", a, b)
}
```
上面是以传值的形式，所以在main函数中值并没有交换，下面改成传地址
```go
package main

import "fmt"

func swap(a, b *int) {
	*a, *b = *b, *a
	fmt.Println("a=,b=", *a, *b)
}

func main() {
	a, b := 10, 20
	swap(&a, &b)
	fmt.Println("main:a=,b=", a, b)
}
```

## 数组
定义
```go
package main

import "fmt"

func main() {
	var id [50]int

	for i := 0; i < len(id); i++ {
		id[i] = i + 1
		fmt.Printf("id[%d]=%d\n", i, id[i])
	}
}
```

### 基本操作

```go
package main

import "fmt"

func main()  {
	var a [10]int
	var b [5]int
	fmt.Printf("len(a) = %d, len(b) = %d\n", len(a),len(b))

	// 定义数组时，指定数组个数必须是常量
	// n :=5  var c [n]int 是错误的

	// 操作数组元素，从0开始，到len()-1，不对称元素， 这个数字叫下标
	// 下标可以是变量或者常量
	a[0] = 1
	i := 1
	a[i] = 2

	// 赋值

	for i :=0; i<len(a); i ++ {
		a[i] = i+1
	}

	// range a 返回第一个为下标，第二个为数据
	for i,data := range a {
		fmt.Printf("a[%d] = %d\n",i,data)
	}
}
```

### array initial
```go
package main

import "fmt"

func main() {
	// 声明定义同时赋值，叫初始化
	// 全部初始化
	var a [5]int = [5]int{1, 2, 3, 4, 5}
	fmt.Println("a=", a)

	b := [5]int{1, 2, 3, 4, 5}
	fmt.Println("b=", b)
	// 部分初始化，没有赋值的默认为0
	c := [5]int{1, 2, 3}
	fmt.Println("c=", c)

	// 指定某个下标的元素赋值，其它部分自动赋值为0
	d := [5]int{2: 10, 4: 20} // 下标为2的赋值为10,下标为4的赋值为20
	fmt.Println("d=", d)
}
#output
a= [1 2 3 4 5]
b= [1 2 3 4 5]
c= [1 2 3 0 0]
d= [0 0 10 0 20]
```

**two dimension initial**
```go
package main

import "fmt"

func main() {
	var a [3][4]int

	k := 0
	for i := 0; i < 3; i++ {
		for j := 0; j < 4; j++ {
			k++
			a[i][j] = k
			fmt.Printf("a[%d][%d]=%d\t", i, j, a[i][j])
		}
		fmt.Printf("\n")
	}
	fmt.Println("a=", a)

	// 自动推导
	b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}
	fmt.Println("b=", b)

	// 部分初始化
	c := [3][4]int{{1, 2, 4}, {5, 6, 7, 8}, {9, 10}}
	fmt.Println("c=", c)

	d := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}}
	fmt.Println("d=", d)

	e := [3][4]int{1: {3, 4, 5}}
	fmt.Println("e=", e)
}
#output
a[0][0]=1       a[0][1]=2       a[0][2]=3       a[0][3]=4       
a[1][0]=5       a[1][1]=6       a[1][2]=7       a[1][3]=8       
a[2][0]=9       a[2][1]=10      a[2][2]=11      a[2][3]=12      
a= [[1 2 3 4] [5 6 7 8] [9 10 11 12]]
b= [[1 2 3 4] [5 6 7 8] [9 10 11 12]]
c= [[1 2 4 0] [5 6 7 8] [9 10 0 0]]
d= [[1 2 3 0] [5 6 7 8] [0 0 0 0]]
e= [[0 0 0 0] [3 4 5 0] [0 0 0 0]]
```

### array compare
same type array can compare and set value 
```go
package main

import "fmt"

func main() {
	a := [3]int{1, 2}
	b := [3]int{1, 2}
	c := [3]int{1, 2, 3}

	fmt.Println(a == b)
	fmt.Println(a == c)

	var d [3]int
	d = c
	fmt.Println("d=", d)
}
```

## rand num
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main()  {
	//step 1: set seed
	//step 2: gen num

	rand.Seed(666) // if the seed is const the rand num is same every time
	for i :=0;i <5;i++{
		// gen num
		fmt.Println("rand= ",rand.Int()) //big number
	}

	rand.Seed(time.Now().UnixNano()) // use sys time as seed
	for i :=0;i<5;i++{
		fmt.Println("rand= ",rand.Intn(100)) // the rand num is smaller than 100
	}
}
```
### bubble sort
```go
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	var a [5]int
	n := len(a)
	for i := 0; i < n; i++ {
		a[i] = rand.Intn(100)
	}

	fmt.Println("rand array n= ", a)
	fmt.Println("bubble sort:")

	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
	fmt.Println("after sort:")
	fmt.Println("sorted a = ", a)
}
```