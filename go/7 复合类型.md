## 指针

### memory address
```go
package main

import "fmt"

func main()  {
	a := 10
	fmt.Printf("a=%d\n",a)
	fmt.Printf("a 的地址是:%v\n", &a)
}
```
### 操作指针指向的内存
```go
package main

import "fmt"

func main() {
	a := 10
	fmt.Printf("a=%d\n", a)
	fmt.Printf("a 的地址是:%v\n", &a)

	// 保存某个变量的地址，需要指针类型 *int保存int的地址， **int 保存 *int的地址
	// 定义一个变量p,类型为×int
	var p *int
	p = &a // p的值为a变量的内在地址
	fmt.Printf("p=%v, &=a=%v\n", p, &a)

	*p = 666 // *p 表示p变量所指向的内存，对它赋值，即修改了指向该地址的变量
	fmt.Printf("*p=%v, a=%v\n", *p, a)
}
```

### 不要操作没有合法指向的内存地址
```go
package main

import "fmt"

func main()  {
	var p *int
	fmt.Println("p=",p) // p 指向空
	// 不要操作没有合法指向的内存地址
	//*p = 666
}
```

### new
```go
package main

import "fmt"

func main() {
	a := 10
	var p *int

	p = &a // p指向一个合法内存

	//p 是*int, 指向int顾炎武
	p = new(int)

	*p = 666
	fmt.Println("*p=", *p)
}
```
new 动态的分配了内存给*p.只管用，不需要考虑释放内存地址的问题

### swap
```go
package main

import "fmt"

func swap(a, b int) {
	a, b = b, a
	fmt.Println("a=,b=", a, b)
}

func main() {
	a, b := 10, 20
	swap(a, b)
	fmt.Println("main:a=,b=", a, b)
}
```
上面是以传值的形式，所以在main函数中值并没有交换，下面改成传地址
```go
package main

import "fmt"

func swap(a, b *int) {
	*a, *b = *b, *a
	fmt.Println("a=,b=", *a, *b)
}

func main() {
	a, b := 10, 20
	swap(&a, &b)
	fmt.Println("main:a=,b=", a, b)
}
```

## 数组
定义
```go
package main

import "fmt"

func main() {
	var id [50]int

	for i := 0; i < len(id); i++ {
		id[i] = i + 1
		fmt.Printf("id[%d]=%d\n", i, id[i])
	}
}
```

### 基本操作

```go
package main

import "fmt"

func main()  {
	var a [10]int
	var b [5]int
	fmt.Printf("len(a) = %d, len(b) = %d\n", len(a),len(b))

	// 定义数组时，指定数组个数必须是常量
	// n :=5  var c [n]int 是错误的

	// 操作数组元素，从0开始，到len()-1，不对称元素， 这个数字叫下标
	// 下标可以是变量或者常量
	a[0] = 1
	i := 1
	a[i] = 2

	// 赋值

	for i :=0; i<len(a); i ++ {
		a[i] = i+1
	}

	// range a 返回第一个为下标，第二个为数据
	for i,data := range a {
		fmt.Printf("a[%d] = %d\n",i,data)
	}
}
```

### array initial
```go
package main

import "fmt"

func main() {
	// 声明定义同时赋值，叫初始化
	// 全部初始化
	var a [5]int = [5]int{1, 2, 3, 4, 5}
	fmt.Println("a=", a)

	b := [5]int{1, 2, 3, 4, 5}
	fmt.Println("b=", b)
	// 部分初始化，没有赋值的默认为0
	c := [5]int{1, 2, 3}
	fmt.Println("c=", c)

	// 指定某个下标的元素赋值，其它部分自动赋值为0
	d := [5]int{2: 10, 4: 20} // 下标为2的赋值为10,下标为4的赋值为20
	fmt.Println("d=", d)
}
#output
a= [1 2 3 4 5]
b= [1 2 3 4 5]
c= [1 2 3 0 0]
d= [0 0 10 0 20]
```

**two dimension initial**
```go
package main

import "fmt"

func main() {
	var a [3][4]int

	k := 0
	for i := 0; i < 3; i++ {
		for j := 0; j < 4; j++ {
			k++
			a[i][j] = k
			fmt.Printf("a[%d][%d]=%d\t", i, j, a[i][j])
		}
		fmt.Printf("\n")
	}
	fmt.Println("a=", a)

	// 自动推导
	b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}
	fmt.Println("b=", b)

	// 部分初始化
	c := [3][4]int{{1, 2, 4}, {5, 6, 7, 8}, {9, 10}}
	fmt.Println("c=", c)

	d := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}}
	fmt.Println("d=", d)

	e := [3][4]int{1: {3, 4, 5}}
	fmt.Println("e=", e)
}
#output
a[0][0]=1       a[0][1]=2       a[0][2]=3       a[0][3]=4       
a[1][0]=5       a[1][1]=6       a[1][2]=7       a[1][3]=8       
a[2][0]=9       a[2][1]=10      a[2][2]=11      a[2][3]=12      
a= [[1 2 3 4] [5 6 7 8] [9 10 11 12]]
b= [[1 2 3 4] [5 6 7 8] [9 10 11 12]]
c= [[1 2 4 0] [5 6 7 8] [9 10 0 0]]
d= [[1 2 3 0] [5 6 7 8] [0 0 0 0]]
e= [[0 0 0 0] [3 4 5 0] [0 0 0 0]]
```

### array compare
same type array can compare and set value 
```go
package main

import "fmt"

func main() {
	a := [3]int{1, 2}
	b := [3]int{1, 2}
	c := [3]int{1, 2, 3}

	fmt.Println(a == b)
	fmt.Println(a == c)

	var d [3]int
	d = c
	fmt.Println("d=", d)
}
```

### array as funct var
```go
package main

import "fmt"

// 数组作为函数参数，是值传递
// 实参数组的每个元素给形参数组拷贝一份
func modify(a [5]int) {
	a[0] = 666
	fmt.Println("modify a =", a)
}

func main() {
	a := [5]int{1, 2, 3, 4, 5}

	modify(a)
	fmt.Println("main: a= ", a)
}
#output
modify a = [666 2 3 4 5]
main: a=  [1 2 3 4 5]
```

### array address as funct params
```go
package main

import "fmt"

// p指向数组a,它是指向数组，是数组指针
// *p 代表指针指向的内存，就是实参a
func modify (p *[5]int) {
	(*p)[0] = 666
	fmt.Println("modify *a =", *p)
}


func main() {
	a := [5]int {1,2,3,4,5}

	modify(&a)

	fmt.Println("main: a=",a)
}
```

## rand num
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main()  {
	//step 1: set seed
	//step 2: gen num

	rand.Seed(666) // if the seed is const the rand num is same every time
	for i :=0;i <5;i++{
		// gen num
		fmt.Println("rand= ",rand.Int()) //big number
	}

	rand.Seed(time.Now().UnixNano()) // use sys time as seed
	for i :=0;i<5;i++{
		fmt.Println("rand= ",rand.Intn(100)) // the rand num is smaller than 100
	}
}
```
### bubble sort
```go
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	var a [5]int
	n := len(a)
	for i := 0; i < n; i++ {
		a[i] = rand.Intn(100)
	}

	fmt.Println("rand array n= ", a)
	fmt.Println("bubble sort:")

	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
	fmt.Println("after sort:")
	fmt.Println("sorted a = ", a)
}
```

## slice
[low:high:max]
low: 下标起点
high:下标终点(不包含）
len = hight-low
cap = max -low

```go
array :=[...]int{10,20,30,0,0}
slice :=array[0:3:5] // 注意第三个参数不是python中的步长，而是容量

package main

import "fmt"

func main()  {
	a := []int{1,2,3,4,5}
	s :=a[0:3:5]
	fmt.Println("s=",s)
	fmt.Println("len(s)=",len(s))
	fmt.Println("cap(s)=",cap(s)) // cap函数查看容量
}

//s= [1 2 3]
//len(s)= 3
//cap(s)= 5
```
### diff between slice & array
slice can change the len and cap
```go
package main

import "fmt"

func main() {
	// 数组[]里面的长度是一个固定的常量，数组不能修改长度
	a := [5]int{}
	fmt.Printf("len = %d, cap=%d\n", len(a), cap(a))

	// 切片[]里面为空，或者为...，切片的长度或容量可以不固定
	s := []int{}
	fmt.Printf("len=%d,cap=%d\n", len(s), cap(s))

	s = append(s, 11) // 给切片追加一个成员
	fmt.Printf("len=%d,cap=%d\n", len(s), cap(s))
}
//len = 5, cap=5
//len=0,cap=0
//len=1,cap=1
```
### two way to create a slice
: and make
```go
package main

import "fmt"

func main()  {
	// 自动推导，同时初始化
	s1 := []int{1,2,3,4}
	fmt.Println("s1=",s1)

	// 借助make函数，格式： make(切片类型，长度，容量）
	s2 := make([]int,5,10)
	fmt.Printf("len=%d, cap=%d\n",len(s2),cap(s2))

	// if no cap, the cap will same as len
	s3 := make([]int, 5)
	fmt.Printf("len=%d, cap=%d\n",len(s3),cap(s3))
}

//s1= [1 2 3 4]
//len=5, cap=10
//len=5, cap=5
```