## 指针

### memory address
```go
package main

import "fmt"

func main()  {
	a := 10
	fmt.Printf("a=%d\n",a)
	fmt.Printf("a 的地址是:%v\n", &a)
}
```
### 操作指针指向的内存
```go
package main

import "fmt"

func main() {
	a := 10
	fmt.Printf("a=%d\n", a)
	fmt.Printf("a 的地址是:%v\n", &a)

	// 保存某个变量的地址，需要指针类型 *int保存int的地址， **int 保存 *int的地址
	// 定义一个变量p,类型为×int
	var p *int
	p = &a // p的值为a变量的内在地址
	fmt.Printf("p=%v, &=a=%v\n", p, &a)

	*p = 666 // *p 表示p变量所指向的内存，对它赋值，即修改了指向该地址的变量
	fmt.Printf("*p=%v, a=%v\n", *p, a)
}
```

### 不要操作没有合法指向的内存地址
```go
package main

import "fmt"

func main()  {
	var p *int
	fmt.Println("p=",p) // p 指向空
	// 不要操作没有合法指向的内存地址
	//*p = 666
}
```

### new
```go
package main

import "fmt"

func main() {
	a := 10
	var p *int

	p = &a // p指向一个合法内存

	//p 是*int, 指向int顾炎武
	p = new(int)

	*p = 666
	fmt.Println("*p=", *p)
}
```
new 动态的分配了内存给*p.只管用，不需要考虑释放内存地址的问题

### swap
```go
package main

import "fmt"

func swap(a, b int) {
	a, b = b, a
	fmt.Println("a=,b=", a, b)
}

func main() {
	a, b := 10, 20
	swap(a, b)
	fmt.Println("main:a=,b=", a, b)
}
```
上面是以传值的形式，所以在main函数中值并没有交换，下面改成传地址
```go
package main

import "fmt"

func swap(a, b *int) {
	*a, *b = *b, *a
	fmt.Println("a=,b=", *a, *b)
}

func main() {
	a, b := 10, 20
	swap(&a, &b)
	fmt.Println("main:a=,b=", a, b)
}
```

## 数组
定义
```go
package main

import "fmt"

func main() {
	var id [50]int

	for i := 0; i < len(id); i++ {
		id[i] = i + 1
		fmt.Printf("id[%d]=%d\n", i, id[i])
	}
}
```

### 基本操作

```go
package main

import "fmt"

func main()  {
	var a [10]int
	var b [5]int
	fmt.Printf("len(a) = %d, len(b) = %d\n", len(a),len(b))

	// 定义数组时，指定数组个数必须是常量
	// n :=5  var c [n]int 是错误的

	// 操作数组元素，从0开始，到len()-1，不对称元素， 这个数字叫下标
	// 下标可以是变量或者常量
	a[0] = 1
	i := 1
	a[i] = 2

	// 赋值

	for i :=0; i<len(a); i ++ {
		a[i] = i+1
	}

	// range a 返回第一个为下标，第二个为数据
	for i,data := range a {
		fmt.Printf("a[%d] = %d\n",i,data)
	}
}
```