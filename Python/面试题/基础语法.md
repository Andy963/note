## python中有哪些可变类型与不可变类型

- 可变类型：会在原来的内存地址上修改元素 比如： list,dict,bytearray,set
- 不可变类型：不会在原来的内存地址上修改元素，而是指向了新的内存引用 比如：int, float，str，tuple, byte, range, frozenset

## 简述数组、链表、队列、堆栈的区别
  数组和链表是存储方式的概念，数组在连续的空间中存储数据，链表在非连续的空间中存储数据；  
  
 队列和堆栈是描述数据存取方法的概念，队列是先进先出，而堆栈是后进先出，队列和堆栈可以用链表来实现，也可以用数组来实现

## 深拷贝和浅拷贝的区别是什么

浅拷贝 (copy.copy())
只复制对象本身及其引用，内部对象（如列表中的列表）仍然指向原始对象。
修改拷贝对象中的内部对象会影响到原始对象。

深拷贝 (copy.deepcopy())
递归复制对象及其所有内部对象，创建完全独立的副本。
修改拷贝对象不会影响到原始对象。

总结
浅拷贝: 只复制对象本身，内部对象的引用保持不变。
深拷贝: 完全独立的副本，内部对象也被复制

### sort 与sorted的区别？
sort(): 是列表对象的一个方法，用于就地排序（即修改原始列表）。它没有返回值（返回 None）
sorted(): 是一个内置函数，接受任何可迭代对象并返回一个新的排序列表。原始对象保持不变

## 面向对象的3个特性是什么
1. 封装：根据职责将属性和方法封装到一个抽象的类中定义类的准则
2. 继承：实现代码的重用，相同的代码不需要重复的编写
3. 多态：不同的子类调用相同的父类，产生不同的结果


## 匿名函数/函数/闭包/对象在做实参时有什么区别

```
1. **匿名函数**：能够完成基本的简单功能，传递是这个函数的引用，只有功能
2. **普通函数**：能够完成比较普通的功能，传递是这个函数的引用，只有功能
3. **闭包**：能够完成比较复杂的功能，传递是这个闭包中的函数和数据，因此传递是功能+数据
4. **对象**：能够完成最为复杂的功能，传递是很多数据和很对功能，因此传递是功能+数据
```

匿名函数的应用场景：列表推导式中，作为列表sort或者sorted的key，map,filter, reduce组合使用。

## 简述什么是进程、线程、协程及它们的区别

```
1. 进程是系统进行资源分配和调度的一个独立单位，一个程序至少有一个进程,一个进程至少有一个线程。
2. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程不能够独立执行，必须依存在进程中
3. 协程是一种比线程更加轻量级的存在，一个线程也可以拥有多个协程。

区别：
1. 进程切换需要的资源很大，效率相对低
2. 线程切换需要的资源一般，效率比进程高
3. 协程切换任务资源很小，三者中效率最高
4. 多进程、多线程根据CPU核数不一样可能是并行，但是协程是在一个线程中所以是并发。

场景：
计算密集型：进程
io密集型：线程
```

创建进程，线程有哪些方式：
multiprocessing 模块的Process类 或者Pool类，subprocess类
threading 模块的Thread类，concurrent.futures 模块的 ThreadPoolExecutor


## 如何区分并行与并发
[[概念#并行（Parallelism）：]] [[概念#并发（Concurrency）：]]

```
1. 执行方式：
    
    - 并行：真正的同时执行。
    - 并发：看似同时执行，实际上可能是快速切换。
2. 硬件要求：
    
    - 并行：需要多核心或多处理器。
    - 并发：单核心也可以实现。
3. 适用场景：
    
    - 并行：适合计算密集型任务。
    - 并发：适合 I/O 密集型或需要频繁等待的任务。
4. 复杂性：
    
    - 并行：通常涉及更复杂的同步和通信机制。
    - 并发：可能需要处理资源竞争和死锁问题。
5. 目标：
    
    - 并行：主要目标是提高性能和吞吐量。
    - 并发：主要目标是提高响应性和资源利用率。

实际应用中的例子：
1. 并行：
    
    - 图像处理软件使用多个 CPU 核心同时处理图像的不同部分。
    - 大数据分析任务在分布式系统中并行执行。
2. 并发：
    
    - Web 服务器同时处理多个 HTTP 请求。
    - 操作系统同时运行多个应用程序。

总结： 并行是关于同时执行多个任务以提高性能，而并发是关于同时管理多个任务以提高效率和响应性。在实际应用中，这两个概念常常结合使用，以充分利用现代计算机系统的能力。理解这两个概念的区别对于设计高效的软件系统和选择适当的编程模型至关重要。
```



## 什么是迭代器，为什么要使用它
[[概念#迭代器]]

```
==迭代器保存的是获取数据的方式而不是结果，所以想用的时候就可以生成，节省大量内存空间，它是一个可以记住遍历的位置的对象。==  
迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。  
  迭代器有两个基本的方法：iter() 和 next()。
```

应用场景：文件遍历，生成器，数据库查询结果

## 互斥锁与GIL的区别
[[概念#互斥锁]] [[概念#GIL]]

```
互斥锁(Mutex)和全局解释器锁(GIL)是两个不同的概念,虽然它们都涉及到并发控制,但有很大的区别:

1. 概念和用途:

   互斥锁(Mutex):
   ⦁ 是一种同步原语,用于多线程编程中保护共享资源
   ⦁ 确保同一时刻只有一个线程可以访问临界区
   ⦁ 可以由程序员显式创建和使用

   全局解释器锁(GIL):
   ⦁ 是Python解释器的一个特性
   ⦁ 用于确保同一时刻只有一个线程在执行Python字节码
   ⦁ 由Python解释器自动管理,程序员无法直接控制

2. 作用范围:

   互斥锁:
   ⦁ 作用于特定的代码段或资源
   ⦁ 可以有多个互斥锁,每个保护不同的资源

   GIL:
   ⦁ 作用于整个Python解释器
   ⦁ 一个Python进程只有一个GIL

3. 粒度:

   互斥锁:
   ⦁ 细粒度控制,可以针对特定资源进行锁定
   ⦁ 允许更高的并发度

   GIL:
   ⦁ 粗粒度控制,影响所有Python字节码的执行
   ⦁ 限制了真正的并行执行

4. 目的:

   互斥锁:
   ⦁ 主要用于防止数据竞争和保证数据一致性

   GIL:
   ⦁ 主要用于简化Python解释器的实现和内存管理

5. 性能影响:

   互斥锁:
   ⦁ 只在需要时影响性能
   ⦁ 合理使用可以提高并发效率

   GIL:
   ⦁ 在CPU密集型多线程场景下可能显著影响性能
   ⦁ 对I/O密集型任务影响较小

6. 适用语言:

   互斥锁:
   ⦁ 几乎所有支持多线程的编程语言都有互斥锁机制

   GIL:
   ⦁ 主要存在于CPython实现中
   ⦁ 其他Python实现如Jython、IronPython没有GIL

7. 控制方式:

   互斥锁:
   ⦁ 程序员可以精确控制锁的获取和释放

   GIL:
   ⦁ 由Python解释器自动管理,程序员无法直接控制

总之,互斥锁是一种通用的同步机制,而GIL是Python解释器的特殊实现。理解它们的区别对于编写高效的Python并发程序非常重要。

```


## `__new__()` 和 `__init__()`的区别

```
_new_作用于_init_之前。前者可以决定是否调用后者，可以决定调用哪个类的_init_方法。

1. 调用顺序：
   ⦁ __new__() 在 __init__() 之前被调用。
   ⦁ __new__() 负责创建并返回实例对象。
   ⦁ __init__() 负责初始化已创建的实例。

2. 返回值：
   ⦁ __new__() 必须返回一个实例（通常是cls的实例）。
   ⦁ __init__() 不应该返回任何值（返回None）。

3. 静态方法 vs 实例方法：
   ⦁ __new__() 是一个类方法（虽然不需要@classmethod装饰器）。
   ⦁ __init__() 是一个实例方法。

4. 参数：
   ⦁ __new__(cls, *args, **kwargs)
   ⦁ __init__(self, *args, **kwargs)

5. 主要用途：
   ⦁ __new__() 主要用于控制实例的创建过程。
   ⦁ __init__() 用于设置实例的初始状态。

6. 单例模式：
   ⦁ __new__() 可以用来实现单例模式。
   ⦁ __init__() 不能阻止新实例的创建。
```

## 队列为什么可以在不同进程间通信，底层原理是什么？又为什么是进程安全的

```
队列可以在不同进程间通信，并且是进程安全的，这主要归功于其底层实现和操作系统提供的机制。让我们深入了解一下其原理：

1. 底层实现原理：

a) 共享内存：
⦁ 队列使用操作系统提供的共享内存机制。
⦁ 在创建队列时，会在共享内存中分配一块区域，所有进程都可以访问这块内存。

b) 序列化：
⦁ 当数据被放入队列时，它会被序列化（通常使用pickle）。
⦁ 序列化后的数据被存储在共享内存中。

c) 同步原语：
⦁ 使用操作系统级别的同步原语（如信号量、互斥锁）来确保对共享内存的安全访问。

2. 进程间通信：

⦁ 当一个进程将数据放入队列时，它实际上是将序列化后的数据写入共享内存。
⦁ 当另一个进程从队列中获取数据时，它从共享内存中读取数据并反序列化。
⦁ 共享内存作为"中间人"，使得不同进程可以交换数据。

3. 进程安全性：

a) 互斥锁：
⦁ 队列使用互斥锁来确保在任何时刻只有一个进程可以修改队列的状态。

b) 原子操作：
⦁ 入队和出队操作被设计为原子操作，即这些操作要么完全执行，要么完全不执行，不会被中途打断。

c) 信号量：
⦁ 使用信号量来控制队列的大小和阻塞行为。
⦁ 例如，当队列满时，put操作会被阻塞；当队列空时，get操作会被阻塞。

4. 具体实现（以Python的multiprocessing.Queue为例）：

⦁ 使用了一个管道（pipe）和一个锁（lock）。
⦁ 管道用于传输实际数据。
⦁ 锁确保了对管道的互斥访问。
⦁ 还使用了一些其他的同步原语，如信号量和事件，来管理队列的大小和状态。

5. 为什么是进程安全的：

⦁ 互斥访问：任何时刻只有一个进程可以修改队列状态。
⦁ 原子操作：关键操作（如入队、出队）是不可分割的。
⦁ 同步机制：使用操作系统级别的同步原语，这些原语本身就是为多进程环境设计的。
⦁ 内存隔离：进程间内存是隔离的，共享内存是唯一的共享点，而对共享内存的访问是受控的。

6. 优势：

⦁ 高效：比起其他IPC（进程间通信）方法，共享内存是非常高效的。
⦁ 安全：利用操作系统提供的同步机制，确保了数据的一致性和完整性。
⦁ 易用：对用户来说，使用起来就像普通的队列一样简单。

总之，队列之所以可以在不同进程间安全通信，是因为它巧妙地利用了操作系统提供的共享内存和同步机制，并在此基础上实现了一套安全、高效的数据传输和同步策略。

```

队列在实际工作中的应用场景：任务队列，消息队列，比如生产者消费者模型，缓冲输入与输出，比如大量日志需要写入时

### python中为什么协程修改共享数据不需要加锁

```
1. 协程是非抢占式的并发:
   ⦁ 协程的执行是协作式的,一个协程必须主动让出控制权(通过yield或await),其他协程才能执行。
   ⦁ 在任一时刻,只有一个协程在运行,不会出现多个协程同时访问共享数据的情况。

2. 单线程执行:
   ⦁ 即使使用asyncio这样的异步框架,协程仍然是在单个线程中执行的。
   ⦁ 不存在真正的并行执行,因此不会有race condition。

3. 协程切换点可预测:
   ⦁ 协程只在明确的yield或await点进行切换。
   ⦁ 程序员可以控制在哪些点允许切换,从而避免在关键操作中途切换。

4. 事件循环调度:
   ⦁ 异步框架(如asyncio)使用事件循环来调度协程。
   ⦁ 事件循环确保了协程的有序执行和切换。

然而,需要注意以下几点:

1. 仍需小心:虽然不需要锁,但仍需谨慎设计以避免逻辑错误。

2. 长时间操作:如果一个协程执行长时间的CPU密集型操作,可能会阻塞其他协程。

3. 多线程场景:如果在多线程环境中使用协程,可能仍需要考虑线程安全性。

4. 外部资源:与外部资源(如文件、数据库)交互时,可能仍需要考虑并发控制。

总的来说,协程的特性确实简化了共享数据的处理,但程序员仍需要理解协程的工作原理,以编写正确和高效的异步代码。
```

## 面向对象

### 简述面向对象的三大特性
```
封装、继承、多态
封装：把对象的属性私有化，同时提供可以被外界访问这些属性的方法。
继承：是使用已存在的类的定义，作为建立新类的基础技术，新类可以增加新的属性或新的方法，也可以用父类的功能，但不能选择性地继承。通过使用继承，能够非常方便地复用这些代码。
多态：(事物有多种形态)表现为程序中定义的引用变量，所指向的具体类型和具体调用的方法，在编译期并不能确定，而是在程序运行期确定
```

### 双下划线和单下划线的区别？
```
1、前后都有双下划线-特殊变量
变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名

2、前面双下划线-私有变量
在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，子类也不行。
双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_${classname}__name，所以，仍然可以通过_${classname}__name来访问__name变量。但是强烈建议你不要这么干，因为不同版本的Python解释器可能会把__name改成不同的变量名

3、前面单下划线-口头私有变量
以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”
```

### 实例变量和类变量的区别？

```python
类变量也叫静态变量，
实例变量也叫对象变量，
区别在于：
   类变量和实例变量的区别在于：类变量是所有对象共有，其中一个对象将它值改变，其他对象得到的就是改变后的结果；而实例变量则属对象私有，某一个对象将其值改变，不影响其他对象；

class MyClass:
    class_attr = 0  # 类属性

# 创建两个实例
obj1 = MyClass()
obj2 = MyClass()

# 验证类属性的初始值
print(obj1.class_attr)  # 输出 0
print(obj2.class_attr)  # 输出 0

# 修改类属性
MyClass.class_attr = 5

# 验证修改后类属性的值
print(obj1.class_attr)  # 输出 5
print(obj2.class_attr)  # 输出 5

# 现在在 obj1 上修改类属性
obj1.class_attr = 10  # 这将创建一个实例属性，obj1 现在有自己的类属性

# 验证各自的类属性
print(obj1.class_attr)  # 输出 10 (实例属性)
print(obj2.class_attr)  # 输出 5  (仍然是类属性)
print(MyClass.class_attr)  # 输出 5 (类属性)
在这个示例中，当我们将 obj1.class_attr 设置为 10 时，在 obj1 上创建了一个实例属性 class_attr。这并不会影响 obj2 或 MyClass 的 class_attr 属性。因此，尽管 class_attr 是一个类属性，但通过某个实例的赋值操作，我们可以使得该实例的属性与类属性的值不再相同
```

### 静态方法和类方法区别？
```
staticmethod主要用途是限定namespace，也就是说这个函数虽然是个普通的function，但是它只有这个class会用到，不适合作为module level的function。这时候就把它作为staticmethod

                类调用           实例化对象调用   需要传入类
classmethod     可以	  可以	需要
staticmethod	可以	可以	不需要
classonlymethod	可以	不可以	需要

```


## 装饰器

好的,这里是一些常见的 Python 装饰器相关的面试题及答案:

### 1. 什么是装饰器?装饰器的作用是什么?

答: 装饰器是一个可调用的对象,它可以接受一个函数作为参数,并返回一个新的函数。装饰器的主要作用是在不修改原函数代码的情况下,为其添加新的功能。常见用途包括日志记录、性能测量、访问控制等。

场景：比如类的类方法，静态访求，属性管理（property)，contextManager(上下文管理)
flask中中间件：before_request, after_request, app.route, login_require
django 中：login_require, csrf_exempt, cache_page, permission_required, transaction.atomic(数据库事务), receiver (信号)

### 2. 请实现一个简单的装饰器,用于记录函数的执行时间。

```python
import time

def timing_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} 执行时间: {end_time - start_time} 秒")
        return result
    return wrapper

@timing_decorator
def some_function():
    time.sleep(2)
    print("Function executed")

some_function()
```


### 3. 什么是带参数的装饰器?如何实现?

答: 带参数的装饰器是可以接受参数的装饰器。实现方法是创建一个外层函数来接受参数,然后在其内部定义实际的装饰器函数。例如:

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
```


### 4. 如何保留被装饰函数的元数据(如函数名、文档字符串等)?

答: 可以使用 Python 标准库中的 functools.wraps 装饰器来保留被装饰函数的元数据:

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        """This is the wrapper function"""
        print("Something is happening before the function is called.")
        result = func(*args, **kwargs)
        print("Something is happening after the function is called.")
        return result
    return wrapper

@my_decorator
def say_hello():
    """This is the say_hello function"""
    print("Hello!")

print(say_hello.__name__)  # 输出: say_hello
print(say_hello.__doc__)   # 输出: This is the say_hello function
```


### 5. 什么是类装饰器?请给出一个示例。

答: 类装饰器是使用类来实现的装饰器。它们通常在需要维护装饰器的状态时使用。示例:

```python
class CountCalls:
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} 已被调用 {self.count} 次")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()
say_hello()
```




