### 03_函数与对象

定义在函数内部的函数，该函数引用外部作用域而不是全局作用域的变量，该函数称为闭包函数。该函数可以在其定义环境外执行。
闭包函数私有化了变量,完成了数据的封装,类似于面向对象. 闭包因为保存了变量,如果大量使用,对内存是有消耗的.

```python
 package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Printf("This is exam 1\n")
	const (
		Man    = 1
		Female = 2
	)
	for {
		second := time.Now().Unix()
		if second%2 == 0 {
			fmt.Println("Female")
		} else {
			fmt.Println("man")
		}
		time.Sleep(1000 * time.Millisecond)
	}

}
outer: [1, 2, 3, 4, 5]
inner: [2, 2, 3, 4, 5]
inner: [3, 2, 3, 4, 5]
[Finished in 0.1s]
```

装饰器:
不影响原有函数的功能,还能添加新的功能

```python
def func1(func):
	def func2():
		print('aaa')
		return func()
	return func2

@func1
def my_print():
	print("hello I'm print")

if __name__ == '__main__':
		# my_print = func1(my_print) = func2
		my_print()
```

### 类
可以通过 `__slots__` 来限制类能加哪些属性,除了这些定义的属性,其它属性是不能添加的
限制类添加属性
```python
class Person:
	pass

p1 = Person()
p1.age =1
p1.num =2

print(p1.age,p1.num)

class Human:
	__slots__ = ['age']
	pass

h1= Human()
h1.age =1
print(h1.age)
h1.num = 2 # AttributeError: 'Human' object has no attribute 'num'
print(h1.num)
```

#### 类方法

静态方法,类方法,普通实例方法都是存储在类中,而不会存储在对象中

实例方法:
```python
class Person:
	def run(self):
		pass
```
标准调用方式是通过实例来调用,self不用手动传,解释器会把调用对象本身传入.
其它调用方式,可以使用类调用,或者间接调用,
```python
class Person:
	def run(self,distance):
		print('run',self,distance)
		pass

p = Person.run
p('123','10km')
# run 123 10km
```
classmethod:
```python
class Person:
	@classmethod
	def run(cls,distance):
		print('run',cls,distance)
		pass

Person.run('10km')

p = Person()
p.run('10km')

p1 = Person.run
p1('11km')

run <class '__main__.Person'> 10km
run <class '__main__.Person'> 10km
run <class '__main__.Person'> 11km
```

#### 创建类的方式 
- 常见方式

```python
class Person:
	age = 0
	def run(self):
		pass
```
- 通过type创建

```python
def run(self):
	print('---',self)

# xxx是类名,Human则是类属性 name的值,所以外部无法直接访问Human
xxx = type("Human",(),{"age":0,"run":run})
print(xxx.__dict__)
xxx.run('10km')

{'age': 0, 'run': <function run at 0x7fafdb457ca0>, '__module__': '__main__', '__dict__': <attribute '__dict__' of 'Human' objects>, '__weakref__': <attribute '__weakref__' of 'Human' objects>, '__doc__': None}
--- 10km
```

#### pydoc
生成文档 
`python3 -m pydoc -b -m doc_name`

#### 私有化属性
_var 受保护的属性:
    - 类内部可以访问
    - 子类内部可以 访问
    - 模块内其他位置访问 : 类,实例均无法访问
    - 跨模块访问: import 导入可以访问,但会提示,  from module import * 导入则无法访问,会报错(如果指定在__all__中则可以导入,如果没有在__all___列表中则报错).
__var 私有属性

#### 只读属性

```python
class Person:
	def __setattr__(self,key,value):
		if key == "age" and key in self.__dict__.keys():
			print("this attr can not set!")
		else:
			# self.key = value 这样会导致无限循环
			self.__dict__[key] = value

p = Person()
# 第一次设置时,p中不含有age属性,所以可以设置
p.age = 18
print(p.age)
# 此时p 中已经有属性age,所以不能修改
p.age = 28
print(p.age)

```