### 03_函数与对象

定义在函数内部的函数，该函数引用外部作用域而不是全局作用域的变量，该函数称为闭包函数。该函数可以在其定义环境外执行。
闭包函数私有化了变量,完成了数据的封装,类似于面向对象. 闭包因为保存了变量,如果大量使用,对内存是有消耗的.

```python
 package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Printf("This is exam 1\n")
	const (
		Man    = 1
		Female = 2
	)
	for {
		second := time.Now().Unix()
		if second%2 == 0 {
			fmt.Println("Female")
		} else {
			fmt.Println("man")
		}
		time.Sleep(1000 * time.Millisecond)
	}

}
outer: [1, 2, 3, 4, 5]
inner: [2, 2, 3, 4, 5]
inner: [3, 2, 3, 4, 5]
[Finished in 0.1s]
```

装饰器:
不影响原有函数的功能,还能添加新的功能

```python
def func1(func):
	def func2():
		print('aaa')
		return func()
	return func2

@func1
def my_print():
	print("hello I'm print")

if __name__ == '__main__':
		# my_print = func1(my_print) = func2
		my_print()
```

### 类
可以通过 `__slots__` 来限制类能加哪些属性,除了这些定义的属性,其它属性是不能添加的
限制类添加属性
```python
class Person:
	pass

p1 = Person()
p1.age =1
p1.num =2

print(p1.age,p1.num)

class Human:
	__slots__ = ['age']
	pass

h1= Human()
h1.age =1
print(h1.age)
h1.num = 2 # AttributeError: 'Human' object has no attribute 'num'
print(h1.num)
```

#### 类方法

静态方法,类方法,普通实例方法都是存储在类中,而不会存储在对象中

实例方法:
```python
class Person:
	def run(self):
		pass
```
标准调用方式是通过实例来调用,self不用手动传,解释器会把调用对象本身传入.
其它调用方式,可以使用类调用,或者间接调用,
```python
class Person:
	def run(self,distance):
		print('run',self,distance)
		pass

p = Person.run
p('123','10km')
# run 123 10km
```
classmethod:
```python
class Person:
	@classmethod
	def run(cls,distance):
		print('run',cls,distance)
		pass

Person.run('10km')

p = Person()
p.run('10km')

p1 = Person.run
p1('11km')

run <class '__main__.Person'> 10km
run <class '__main__.Person'> 10km
run <class '__main__.Person'> 11km
```

#### 创建类的方式 
- 常见方式

```python
class Person:
	age = 0
	def run(self):
		pass
```
- 通过type创建

```python
def run(self):
	print('---',self)

# xxx是类名,Human则是类属性 name的值,所以外部无法直接访问Human
xxx = type("Human",(),{"age":0,"run":run})
print(xxx.__dict__)
xxx.run('10km')

{'age': 0, 'run': <function run at 0x7fafdb457ca0>, '__module__': '__main__', '__dict__': <attribute '__dict__' of 'Human' objects>, '__weakref__': <attribute '__weakref__' of 'Human' objects>, '__doc__': None}
--- 10km
```

#### pydoc
生成文档 
`python3 -m pydoc -b -m doc_name`

#### 私有化属性
_var 受保护的属性:
    - 类内部可以访问
    - 子类内部可以 访问
    - 模块内其他位置访问 : 类,实例均无法访问
    - 跨模块访问: import 导入可以访问,但会提示,  from module import * 导入则无法访问,会报错(如果指定在__all__中则可以导入,如果没有在__all___列表中则报错).
__var 私有属性

#### 只读属性

```python
class Person:
	def __setattr__(self,key,value):
		if key == "age" and key in self.__dict__.keys():
			print("this attr can not set!")
		else:
			# self.key = value 这样会导致无限循环
			self.__dict__[key] = value

p = Person()
# 第一次设置时,p中不含有age属性,所以可以设置
p.age = 18
print(p.age)
# 此时p 中已经有属性age,所以不能修改
p.age = 28
print(p.age)

```

#### 内置属性

```python
__dict__ # 类的属性
__bases__ # 类的父类所构成的元组
__doc__ # 文档
__name__ # 类名
__module__ # 定义所在的模块 
```

#### 内置方法 
##### 信息格式化方法
`__str__, __repr__`

```python

class Person:
	def __init__(self,name,age):
		self.name = name
		self.age = age

	def __str__(self):
		return f"{self.name}今年{self.age}岁"
 def __repr__(self):
   return 'repr'

p = Person('andy','30')
print(p)
print(repr(p))
andy今年30岁
<__main__.Person object at 0x7fef55747ee0>
```
##### __call__ 
让对象具备被调用的能力
```python
class Person:
	def __call__(self):
		print("run")

p = Person()
p()
run
```
应用场景:类似偏函数
```python
def create_pen(p_type,p_color):
	print(f"create a {p_color}-{p_type}")


create_pen('钢笔','红色')
create_pen('钢笔','黑色')

from functools import partial

def create_pen(p_color,p_type):
	print(f"create a {p_color}-{p_type}")


# create_pen('钢笔','红色')
# create_pen('钢笔','黑色')

# 这种情况会导致出错,可以将p_type参数换到后面的位置
# gangPen = partial(create_pen,p_type="钢笔")
# gangPen('黄色')
# gangPen('绿色')


# 针对上面的偏函数,可以通过面向对象的方式实现
class PenFactory:
	def __init__(self,p_type):
		self.p_type = p_type

	def __call__(self,p_color):
		print(f"create a {p_color} - {self.p_type}")

pencilFac = PenFactory('铅笔')
pencilFac('红色')
pencilFac('黄色')
#create a 红色 - 铅笔
#create a 黄色 - 铅笔
```

##### 切片

```python

class Person:
	def __init__(self):
		self.items = [1,2,3,4,5,5,6,7]

	def __setitem__(self,key,value):
		# print(key.start)
		# print(key.stop)
		# print(key.step)
		# print(value)
		# 防止传入的key为字符串类型的情况
		# slice为内置类,直接用即可
		if isinstance(key,slice):
			self.items[key.start:key.stop:key.step] = value

	def __getitem__(self,item):
		print("getitem",item)

	def __delitem__(self,key):
		print("delete item",key)

p = Person()
p[0:3:1] = ['a','b']
print(p.items)
# 只能修改,否则为空,无法修改
# ['a', 'b', 4, 5, 5, 6, 7]
```

##### 比较
比较操作符
```python
class Person:
    def __init__(self, age, height):
        self.age = age
        self.height = height

    def __eq__(self, other):
        return self.age == other.age

    def __ne__(self, other):
        # 如果定义了本方法,判断不等时,先走本方法
        # 如果没定义本方法,则通过等于进       pass
        pass

    def __gt__(self, other):
        # 如果没有定义小于的比较操作，那么解释器会通过调换参数人方式来进行比较
        pass

    def __lt__(self, other):
        pass

    def __ge__(self, other):
        pass

    def __le__(self, other):
        pass
```

##### 布尔型
布尔值需要 定义 `__bool__`方法

```python
class Person:
    def __init__(self, age):
        self.age = age

    def __bool__(self):
        return self.age > 18


p = Person(19)
if p:
    print("已经成年")
#已经成年
```

##### 遍历操作
默认情况下遍历会调用__getitem__方法
```python
class Person:
    def __init__(self, age):
        self.age = age

    def __getitem__(self, item):
        self.age += 1
        if self.age > 18:
            raise StopIteration("成年了")
        return self.age


p = Person(1)
for i in p:
    print(i)


class Person:
    def __init__(self, age):
        self.age = age

    def __getitem__(self, item):
        self.age += 1
        if self.age > 18:
            raise StopIteration("成年了")
        return self.age

    def __iter__(self):
        # 如果定义了本方法,本方法优先级比__getitem__高
        # 在遍历时,本方法返回一个迭代器对象,并不断调用 __next__方法来获取下一个值
        print('iter')
        # return iter([1,2,3])
        return self

    def __next__(self):
        self.age += 1
        if self.age > 18:
            raise StopIteration("成年了")
        return self.age


p = Person(1)
for i in p:
    print(i)

```