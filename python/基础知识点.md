# 基础知识点


### python 匹配中文
```
2E80～33FFh：中日韩符号区。收容康熙字典部首、中日韩辅助部首、注音符号、日本假名、韩文音符，中日韩的符号、标点、带圈或带括符文数字、月份，以及日本的假名组合、单位、年号、月份、日期、时间等。
3400～4DFFh：中日韩认同表意文字扩充A区，总计收容6,582个中日韩汉字。
4E00～9FFFh：中日韩认同表意文字区，总计收容20,902个中日韩汉字。
A000～A4FFh：彝族文字区，收容中国南方彝族文字和字根。
AC00～D7FFh：韩文拼音组合字区，收容以韩文音符拼成的文字。
F900～FAFFh：中日韩兼容表意文字区，总计收容302个中日韩汉字。
FB00～FFFDh：文字表现形式区，收容组合拉丁文字、希伯来文、阿拉伯文、中日韩直式标点、小符号、半角符号、全角符号等。
比如需要匹配所有中日韩非符号字符,那么正则表达式应该是^[\u3400-\u9FFF]+$
理论上没错, 可是我到msn.co.ko随便复制了个韩文下来, 发现根本不对, 诡异
再到msn.co.jp复制了个’お’, 也不得行..
然后把范围扩大到^[\u2E80-\u9FFF]+$, 这样倒是都通过了, 这个应该就是匹配中日韩文字的正则表达式了, 包括我們臺灣省還在盲目使用的繁體中文
而关于中文的正则表达式, 应该是^[\u4E00-\u9FFF]+$, 和论坛里常被人提起的^[\u4E00-\u9FA5]+$很接近
需要注意的是论坛里说的^[\u4E00-\u9FA5]+$这是专门用于匹配简体中文的正则表达式, 实际上繁体字也在里面, 我用测试器测试了下’中華人民共和國’, 也通过了, 当然, ^[\u4E00-\u9FFF]
```


### hashlib简单实例

```python
import hashlib
string = 'hello'
md = hashlib.md5()
md.update(string.encode('utf-8'))
md5string = md.hexdigest()
```

### 头像实时预览
思路：文件选择框的change事件，获取到加载到内存中的文件对象，通过readAsDataURL方法读取内存中文件对象为Url,然后重新加载到文件显示位置
```js
    #  文件change时将文件的url赋值过来
    #   头像预览, 可能多次选择,要跟随选择发生变化,所以应该用change
    $("#avatar_file").change(function(){
        var ele_file = $(this)[0].files[0];  # this.files
        var reader = new FileReader();  # 默认没有返回值,将值赋值给了self.result

        reader.readAsDataURL(ele_file); # 当前数据的url
    reader.onload = function(){
        $("#preScan").attr("src", this.result);
    }
    })
```

### csrf_token携带方式

```js
#方式一
$.ajaxSetup({
    data: {csrfmiddlewaretoken: '{{ csrf_token }}' },

});
# 上面的方式它的局限性在于必须放在html中,如果放在独立js文件中,客户端浏览器会请求js文件,此时csrf_taken没有渲染

# 方式二:
data:{
    "csrfmiddlewaretoken":$("[name='csrfmiddlewaretoken']").val(); 
}

#方式三:
<script src="{% static 'js/jquery.cookie.js' %}"></script> 
    $.ajax({
    headers:{"X-CSRFToken":$.cookie('csrftoken')},
    })
```

## snippet

### 栈

```py
class Stack:

    def __init__(self):
        self.items = []

    def push(self, item):
        return self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def isEmpty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

### 队列 

```py
class Queue:

    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.insert(0, item)

    def dequeue(self):
        self.itesm.pop()

    def isEmpty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

### 链表

```py

```


### python2&3
```
py2:                               py3
u"string" unicode                  str           "string"
"string"   str                     bytes         b"string"
```

### 迭代器&可迭代对象 & 生成器
迭代器：内部具有__next__方法，获取下一个值，只能前进不能倒退。如果没有元素了，那么抛出StopIteration异常
可迭代对象：内部具有 __iter__ 方法且返回一个迭代器。
生成器：本质是迭代器,只是需要我们自己用代码去构建。

### yield与return的区别：
return一般在函数中只设置一个，他的作用是终止函数，并且给函数的执行者返回值。
yield在生成器函数中可设置多个，他并不会终止函数，next会获取对应yield生成的元素。

### 闭包函数
定义在函数内部的函数，该函数引用外部作用域而不是全局作用域的变量，该函数称为闭包函数


### 装饰器
```py
import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print('call %s():' % func.__name__)
        return func(*args, **kw)
    return wrapper
```

带参数 
```py
import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print('%s %s():' % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
```

### 进，线，协程

#### 进程
```py
import time
from multiprocesse import Process

def task(name):
    print('%s is runing' % name)
    time.sleep(1)
    print('finish')

if '__name__' == '__main__':
    p = Process(target=task, args=('andy',)
    p.start()

方法
p.start()：启动进程，并调用该子进程中的p.run() 
p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  
p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
p.is_alive():如果p仍然运行，返回True
p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程

属性
p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
p.name:进程的名称
p.pid：进程的pid
p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)
p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）

僵尸进程：如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作
```

#### 线程
在主进程下开启多个线程,每个线程都跟主进程的pid一样
同一进程内的线程共享该进程的初始数据

无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁
对主进程来说，运行完毕指的是主进程代码运行完毕
对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕.
```py
import time
from threading import Thread

def task(name):
    print("%s is runing" % name)
    time.sleep(2)

if "__name__" == "__main__":
    t = Thread(target=task,args=('andy',))
    t.setDaemon(True) # 一定要在start之前设置
    t.start()

#锁
from threading import Lock
lock = Lock()
lock.acquire()
lock.release()
```

#### GIL
全局解释器锁： 同一时间内python 解释器只能解释执行一个线程的代码。无法利用多核的性能。遇到I/O操作，操作系统会释放GIL锁，cpu使用权被切换，当前线程挂起，另一个线程进入。即可以使用并发。