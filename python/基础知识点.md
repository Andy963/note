# 基础知识点


### python 匹配中文
2E80～33FFh：中日韩符号区。收容康熙字典部首、中日韩辅助部首、注音符号、日本假名、韩文音符，中日韩的符号、标点、带圈或带括符文数字、月份，以及日本的假名组合、单位、年号、月份、日期、时间等。
3400～4DFFh：中日韩认同表意文字扩充A区，总计收容6,582个中日韩汉字。
4E00～9FFFh：中日韩认同表意文字区，总计收容20,902个中日韩汉字。
A000～A4FFh：彝族文字区，收容中国南方彝族文字和字根。
AC00～D7FFh：韩文拼音组合字区，收容以韩文音符拼成的文字。
F900～FAFFh：中日韩兼容表意文字区，总计收容302个中日韩汉字。
FB00～FFFDh：文字表现形式区，收容组合拉丁文字、希伯来文、阿拉伯文、中日韩直式标点、小符号、半角符号、全角符号等。
比如需要匹配所有中日韩非符号字符,那么正则表达式应该是^[\u3400-\u9FFF]+$
理论上没错, 可是我到msn.co.ko随便复制了个韩文下来, 发现根本不对, 诡异
再到msn.co.jp复制了个’お’, 也不得行..
然后把范围扩大到^[\u2E80-\u9FFF]+$, 这样倒是都通过了, 这个应该就是匹配中日韩文字的正则表达式了, 包括我們臺灣省還在盲目使用的繁體中文
而关于中文的正则表达式, 应该是^[\u4E00-\u9FFF]+$, 和论坛里常被人提起的^[\u4E00-\u9FA5]+$很接近
需要注意的是论坛里说的^[\u4E00-\u9FA5]+$这是专门用于匹配简体中文的正则表达式, 实际上繁体字也在里面, 我用测试器测试了下’中華人民共和國’, 也通过了, 当然, ^[\u4E00-\u9FFF]


### hashlib简单实例

```python
import hashlib
string = 'hello'
md = hashlib.md5()
md.update(string.encode('utf-8'))
md5string = md.hexdigest()
```

### 头像实时预览
思路：文件选择框的change事件，获取到加载到内存中的文件对象，通过readAsDataURL方法读取内存中文件对象为Url,然后重新加载到文件显示位置
```js
    #  文件change时将文件的url赋值过来
    #   头像预览, 可能多次选择,要跟随选择发生变化,所以应该用change
    $("#avatar_file").change(function(){
        var ele_file = $(this)[0].files[0];  # this.files
        var reader = new FileReader();  # 默认没有返回值,将值赋值给了self.result

        reader.readAsDataURL(ele_file); # 当前数据的url
    reader.onload = function(){
        $("#preScan").attr("src", this.result);
    }
    })
```

### csrf_token携带方式

```js
#方式一
$.ajaxSetup({
    data: {csrfmiddlewaretoken: '{{ csrf_token }}' },

});
# 上面的方式它的局限性在于必须放在html中,如果放在独立js文件中,客户端浏览器会请求js文件,此时csrf_taken没有渲染

# 方式二:
data:{
    "csrfmiddlewaretoken":$("[name='csrfmiddlewaretoken']").val(); 
}

#方式三:
<script src="{% static 'js/jquery.cookie.js' %}"></script> 
    $.ajax({
    headers:{"X-CSRFToken":$.cookie('csrftoken')},
    })
```