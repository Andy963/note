## 传递依赖

[[03_Database/definition#依赖]]

```
传递依赖是数据库设计中的一个重要概念，主要在第三范式（3NF）中被讨论。它指的是在一个关系（表）中，某个非主键列不仅依赖于主键，还依赖于其他非主键列。换句话说，存在 A → B → C 的关系，其中 A 是主键，B 和 C 都是非主键列。

以下是对传递依赖的更详细解释：

1. 定义：
   如果存在函数依赖 A → B 和 B → C，且 A 是主键，B 不是主键的任何一部分，那么 C 对 A 的依赖为传递依赖。

2. 示例：
   假设有一个表包含以下字段：学号（主键）、系名、系主任

   在这个例子中：
   ⦁ 学号 → 系名
   ⦁ 系名 → 系主任

   因此，系主任对学号存在传递依赖，因为系主任不直接依赖于学号，而是通过系名间接依赖于学号。

3. 问题：
   传递依赖可能导致以下问题：
   ⦁ 数据冗余：同一系的学生会重复存储相同的系主任信息。
   ⦁ 更新异常：更改一个系的系主任需要更新多条记录。
   ⦁ 插入异常：无法仅插入系和系主任的信息而不插入学生信息。
   ⦁ 删除异常：删除某系的所有学生可能导致该系的信息完全丢失。

4. 解决方法：
   为了满足第三范式，应该将包含传递依赖的表拆分为多个表：
   ⦁ 表1：学号（主键）、系名
   ⦁ 表2：系名（主键）、系主任

通过消除传递依赖，可以提高数据库的规范化程度，减少数据冗余和异常情况的发生。然而，在某些情况下，出于性能或其他实际考虑，可能会保留一些传递依赖，这就是所谓的反范式化设计。
```

## 依赖

```
在数据库理论中,"依赖"指的是数据之间的关系,特别是一个数据项如何决定另一个数据项的值。当我们说"A 依赖 B"时,意味着知道 B 的值就可以确定 A 的值。

函数依赖（Functional Dependency）是描述这种关系的正式方式。如果 A 函数依赖于 B,我们写作 B → A。

举例说明 "A 依赖 B":

1. 学生信息例子:
   假设有一个学生信息表,包含学号、姓名、所在班级、班主任等字段。
   ⦁ 学号 → 姓名 (学号确定了就能知道姓名)
   ⦁ 学号 → 所在班级 (学号确定了就能知道所在班级)
   ⦁ 所在班级 → 班主任 (知道班级就能确定班主任)

   在这个例子中,姓名依赖于学号,所在班级依赖于学号,班主任依赖于所在班级。

2. 订单系统例子:
   考虑一个订单系统,包含订单号、客户ID、客户姓名、商品编码、商品名称、单价等字段。
   ⦁ 订单号 → 客户ID (一个订单号对应一个客户ID)
   ⦁ 客户ID → 客户姓名 (一个客户ID确定一个客户姓名)
   ⦁ 商品编码 → 商品名称 (一个商品编码确定一个商品名称)
   ⦁ 商品编码 → 单价 (一个商品编码确定一个单价)

   在这个例子中,客户ID依赖于订单号,客户姓名依赖于客户ID,商品名称和单价都依赖于商品编码。

3. 地理信息例子:
   假设有一个地址信息表,包含邮政编码、城市、省份等字段。
   ⦁ 邮政编码 → 城市 (知道邮政编码就能确定城市)
   ⦁ 城市 → 省份 (知道城市就能确定省份)

   这里,城市依赖于邮政编码,省份依赖于城市。
```

## ONLY_FULL_GROUP_BY

```
MySQL中的ONLY_FULL_GROUP_BY是一个SQL模式选项，它对GROUP BY子句的使用施加了更严格的规则。这个选项的主要作用是确保查询结果的确定性和一致性，特别是在使用GROUP BY时。以下是它的主要作用和影响：

1. 严格的列选择规则：
   当启用ONLY_FULL_GROUP_BY时，SELECT列表、HAVING条件或ORDER BY列表中的每一列，要么必须在GROUP BY子句中出现，要么必须是聚合函数的结果。这可以防止出现不确定的查询结果。

2. 提高查询的可预测性：
   通过强制执行这些规则，查询结果变得更加可预测和一致，减少了因不当使用GROUP BY而导致的意外结果。

3. 符合SQL标准：
   这个模式使MySQL更接近SQL标准的行为，特别是在处理GROUP BY查询时。

4. 错误检测：
   如果查询违反了ONLY_FULL_GROUP_BY的规则，MySQL会抛出错误，而不是返回可能不一致或不确定的结果。

5. 改变查询编写方式：
   启用此模式可能需要开发者重新考虑和修改一些现有的查询，以确保它们符合更严格的规则。

6. 性能影响：
   在某些情况下，遵守这些规则可能会导致查询性能略有下降，因为可能需要更复杂的查询结构。

示例：
假设有一个表orders，包含id, customer, product, amount列。

不启用ONLY_FULL_GROUP_BY时，以下查询可能会执行成功：

SELECT customer, product, SUM(amount)
FROM orders
GROUP BY customer;


但启用ONLY_FULL_GROUP_BY后，这个查询会报错，因为product列既不在GROUP BY子句中，也不是聚合函数的结果。

正确的查询应该是：

SELECT customer, MAX(product), SUM(amount)
FROM orders
GROUP BY customer;


总的来说，ONLY_FULL_GROUP_BY选项通过强制执行更严格的GROUP BY规则，提高了查询结果的可靠性和一致性，但也可能需要开发者调整一些现有的查询逻辑。

```