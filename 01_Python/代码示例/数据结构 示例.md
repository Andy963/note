

### 栈

```python

class Stack:

    def __init__(self):
        self.items = []

    def push(self, item):
        return self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[-1]

    def isEmpty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

### 队列 

```python

class Queue:

    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.insert(0, item)

    def dequeue(self):
        self.items.pop()

    def isEmpty(self):
        return self.items == []

    def size(self):
        return len(self.items)
```

### 双端队列

```python

class TwoQueue:
    def __init__(self):
        self.items = []


    def deque(self):
        return self.items.pop()

    def addFront(self,item):
        self.items.insert(0, item)

    def addRear(self,item):
        self.items.append(item)

    def removeFront(self):
        return self.items.pop(0)

    def removeRear(self):
        return self.items.pop()

    def isEmpty(self):
        return self.items == []

    def size(self):
        return len(self.items)

```

### 链表

```python

class Node:

    def __init__(self, item):
        self.item = item
        self.next = None


class Link:

    def __init__(self):
        self._head = None

    def add(self, item):
        #  向头部添加
        node = Node(item)
        node.next = self._head
        self._head = node

    def travel(self):
        #  遍历
        cur = self._head
        while cur:
            print(cur.item)
            cur = cur.next

    @property
    def is_empty(self):
        # 是否为空
        return self._head == None

    @property
    def length(self):
        # 长度
        cur = self._head
        count = 0

        while cur:
            count += 1
            cur = cur.next
        return count

    def append(self, item):
        node = Node(item)
        cur = self._head
        pre = None
        #  空链表
        if self._head == None:
            self._head = node
            return
        #  非空
        while cur:
            pre = cur
            cur = cur.next
        pre.next = node

    def search(self, item):
    	#  查找某个元素
        cur = self._head
        find = False
        while cur:
            if cur.item == item:
                find = True
                break
            else:
            	cur = cur.next
        return find


    def insert(self, pos, item):
        node = Node(item)
        cur = self._head
        pre = None

        if pos > self.length - 1:
            self.append(item)
            return

        for i in range(pos):
            pre = cur
            cur = cur.next
        pre.next = node
        node.next = cur

    def remove(self, item):
        cur = self._head
        pre = None

        if item == cur.item:
            self._head = cur.next
            return

        while cur:
            if cur.item != item:
                pre = cur
                cur = cur.next
            else:
                break
        pre.next = cur.next

#逆置
def reverse(self):
	if self._head:
	cur = self._head
		pre = None
	cur_next = cur.next
		
	if cur.next is none:
			return
      while True:
            cur.next = pre
            pre = cur 
            cur = cur_next
            
            if cur == None:
                break
            cur_next = cur_next.next
        self._head = pre

def reverse_linked_list(head):
    """
    链表逆置
    :param head:
    :return:
    """
    if not head or not head.next:
        return head

    prev_node = None
    current_node = head
    next_node = head.next

    while True:
        current_node.next = prev_node
        if not next_node:
            break
        prev_node = current_node
        current_node = next_node
        next_node = current_node.next
    return current_node

```

### 二叉树

```python

class Node:

    def __init__(self, item):
        self.item = item
        self.left = None
        self.right = None


class Tree:

    def __init__(self):
        self.root = None

    def add(self, item):
        node = Node(item)
        if self.root == None:
            self.root = node
            return

        cur = self.root
        queue = [cur]
        while queue:
            root = queue.pop(0)

            if root.left != None:
                queue.append(root.left)
            else:
                root.left = node
                break

            if root.right != None:
                queue.append(root.right)
            else:
                root.right = node
                break

    def travel(self):
        cur = self.root
        queue = [cur]
        if self.root == None:
            return
        while queue:
            root = queue.pop(0)
            print(root.item)
            if root.left != None:
                queue.append(root.left)
            if root.right != None:
                queue.append(root.right)

    def forward(self, root):
        if root == None:
            return
        print(root.item)
        self.forward(root.left)
        self.forward(root.right)

    def middle(self, root):
        if root == None:
            return

        self.middle(root.left)
        print(root.item)
        self.middle(root.right)

    def back(self, root):
        if root == None:
            return

        self.back(root.left)
        self.back(root.right)
        print(root.item)


tree = Tree()
tree.add(1)
tree.add(2)
tree.add(3)
tree.add(4)
tree.add(5)

tree.forward(tree.root)
```
### 排序二叉树
```py
class Node:

    def __init__(self, item):
        self.item = item
        self.left = None
        self.right = None


class SortTree:
    def __init__(self):
        self.root = None

    def add(self,item):
        node = Node(item)
        cur = self.root
        if self.root == None:
            self.root = node
            return

        while True:
            if node.item < cur.item:
                if cur.left == None:
                    cur.left = node
                    break
                else:
                    cur = cur.left
            else:
                if cur.right == None:
                    cur.right = node
                    break
                else:
                    cur = cur.right

    def middle(self, root):
        if root == None:
            return

        self.middle(root.left)
        print(root.item)
        self.middle(root.right)

tree = SortTree()
nums = [3,8,7,6,2,1]
for i in nums:
    tree.add(i)
tree.middle(tree.root)
```

### 求第二大的值

```python

def second(nums):
    if nums[0] > nums[1]:
        max_val = nums[0]
        next_max_val = nums[1]
    else:
        max_val = nums[1]
        next_max_val = nums[0]

    n = len(nums)

    for index in range(2,n):
        if nums[index] > max_val:
            next_max_val,max_val = max_val, nums[index]
        elif nums[index] > next_max_val:
            next_max_val = nums[index]
    return next_max_val

res = second([-6,4,7,9,3,10,-100])
print(res)
```

### 两个队列维护一个栈
```py
import queue


class Stack(object):
    def __init__(self):
        self.master_queue = queue.Queue()
        self.minor_queue = queue.Queue()

    def push(self, value):
        """
        入栈
        """
        self.master_queue.put(value)

    def pop(self):
        """
        出栈
        """
        if self.master_queue.qsize() == 0:
            return None

        while True:
            if self.master_queue.qsize() == 1:
                value = self.master_queue.get()
                break
            self.minor_queue.put(self.master_queue.get())

        self.master_queue, self.minor_queue = self.minor_queue, self.master_queue

        return value

obj = Stack()
obj.push('武沛齐')
obj.push('Alex')
obj.push('肖峰')

v1 = obj.pop()
v2 = obj.pop()
v3 = obj.pop()

print(v1,v2,v3)
```

### 队列维护成一个栈
```py
import collections
class MyStack:
    
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.stack = collections.deque([])
        

    def push(self, x: int) -> None:
        """
        Push element x onto stack.
        """
        self.stack.append(x)

    def pop(self) -> int:
        """
        Removes the element on top of the stack and returns that element.
        """
        return self.stack.pop()
    

    def top(self) -> int:
        """
        Get the top element.
        """
        return self.stack[-1]


    def empty(self) -> bool:
        """
        Returns whether the stack is empty.
        """
        return len(self.stack)==0


# Your MyStack object will be instantiated and called as such:
# obj = MyStack()
# obj.push(x)
# param_2 = obj.pop()
# param_3 = obj.top()
# param_4 = obj.empty()
```

