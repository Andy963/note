## 配置

goProxy 配置
`export GOPROXY=https://goproxy.cn,direct`

如果只想导入包初始化,不需要引用里面任何方法,变量,可以加下划线
```go
import(  
    _ module_name
)
```

### 配置环境变量

```sh
export PATH=/usr/local/go:$PATH
```

GOROOT:
```shell
 go 的安装目录 
 export GOROOT=/usr/local/go
```

GOPATH:
```shell
 项目代码
 export GOPATH=/home/andy/GoProject
```
GOBIN:

```shell
bin文件目录
export GOBIN=/home/andy/GoProject/bin
```

- go run: 编译并运行Go程序,但不会生成可执行文件。适用于快速测试和调试代码。

- go build: 编译Go程序,生成可执行的二进制文件,但不会运行该二进制文件。 

- go install: 编译并安装Go程序。它首先通过go build生成二进制可执行文件,然后将该二进制文件移动到GOPATH/bin目录下。

### 工作区
go 代码必须放在工作区（特定的目录），它包含三个子目录，src(必须),pkg,bin.
- src :source code
- pkg : go install 命令构建安装后的代码包
- bin : go install 命令完成安装后由源码生成的可执行文件

gopath:导包默认是从gopath导入 


### 导入包（Import package）

#### import 
```go
package main

import "fmt"
import "os"

//import (
//	"fmt"
//	"os"
//)
func main()  {
	fmt.Println("import fmt, os")
	fmt.Println("os.Args=", os.Args)
}

```
#### . dot

```go
package main

import . "fmt"
import . "os"

func main() {
	Println("import fmt, os")
	Println("os.Args=", Args)
}
```
#### alias package
```go
package main

import io "fmt" // io is alias to fmt

func main() {
	io.Println("import fmt, os")
}
```

#### _ ignore package
导入一个包，但不直接使用包里面的函数，而是引用了包里面的init
```go
import (
  _ "fmt"
  )
```

#### multifile programming
- 分文件编程，多个源文件放在src目录，
- 设置gopath环境变量
- 同一目录，包名必须一致
- 同一个目录，调用同目录下文件里的函数直接调用即可，无需包名
main.go
```go
package main

func main() {
	f1_function()
}
```
f1.go
```go
package main

import "fmt"

func f1_function() {
	fmt.Println("f1 function")
}
```

#### multifolder programming
file path:
```
src
├── calc
│   └── f1.go
└── main.go
```

main.go
```go
package main

import "calc"

func main() {
	calc.F1()
}
```

calc/calc.go
```go
package calc

import "fmt"

func F1() {
	fmt.Println("f1 function")
}
```
before run this go file, you should add the **parent folder** to go path:`export GOPATH=/home/and/Goprojects/6project/`. the sub foler name matters, but not the file in the subfolder,you can change the file name in calc folder

#### init
main.go
```go
package main

import "calc"
import "fmt"

func init() {
	fmt.Println("Init in main")
}
func main() {
	calc.F1()
}
```
f1.go
```go
package calc

import "fmt"

func init() {
	fmt.Println("Init in calc.f1")
}

func F1() {
	fmt.Println("f1 function")
}
```
#output
```go
Init in calc.f1
Init in main
f1 function
```

when you import the package,it will run the init function in that package first. then the main package init function, and other code last.

#### go install

if you have a project with multi file:
- set the GOPATH env variables
- set the GOBIN env variables
- run go install main.go
this cmd will create the bin, pkg folder automacticlly.

### 包用法

   包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在GOPATH/src/a/b/ 下定义一个包 c。在包 c 的源码中只需声明为package c，而不是声明为package a/b/c，但是在导入 c 包时，需要带上路径，例如import "a/b/c"。

包的习惯用法：
- 包名一般是小写的，使用一个简短且有意义的名称。
- 包名一般要和所在的目录同名，也可以不同，包名中不能包含- 等特殊符号。
- 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/- userName/projectName 目录下。
- 包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。
- 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。
- 
```
example
├── add
│   └── add.go
└── main
    └── main.go
```
add.go
```go
package add


var Name string = "hello world"
var Age int = 10

func init() {
	Name = "I'm Name"
	Age = 29
}
```

main.go
```go
package main

import (
	"example/add"
	"fmt"
)

func main() {
	fmt.Println("Name=", add.Name)
	fmt.Println("Age=", add.Age)
}
```
需要 注意的是，在add中，不管全局变量声明是在init函数前还是后结果一样，因为它的执行顺序是：先全局变量，再init函数(如果有init函数的话)

#### 包取别名
别名在前面
```go
import (
	package "example/add"
	"fmt"
)
func main() {
	fmt.Println("Name=", packageAdd.Name)
	fmt.Println("Age=", packageAdd.Age)
}
```

#### 初始化而不引用
```go
import (
    _ "example/sub"
    )
```

### 可见性

如果想要使用别的包的函数，结构体类型，结构体成员，
函数名，类型名，结构体成员变量名，首字母必须大写，才可见
如果首字母是小写，只能在同一个包里使用。

## 变量
### 变量定义，推导

```go
package main // 必须有一个Main 包

import "fmt" // 导入包，必须要使用


func main(){
	// 变量声明格式 var name 类型 变量声明了必须使用
	// 只是声明，没有初始化的变量，默认值0
	// 同一个{}里，声明的变量名是唯一的
	// 可以同时声明多个变量： var b,c int
	fmt.Println("hello go")

    	// 自动推导类型，必须初始化，%T打印变量数据类型
    	// 同一推导的变量名不能使用两次
	c := 30
	fmt.Printf("c type is %T\n",c)

	// 常量定义
 // const 只能修饰boolean,number,string类型变量
	const d int = 10  // 可以简写为const d =10
	fmt.Printf("d =%d\n",d)

	// 常量的推导不需要冒号
	const e = 20
	fmt.Printf("e = %d\n",e)
    
}
```
### 匿名变量
go 中也支持直接调换两个变量：a,b = b,a
匿名变量：
```go
func lambda()(a,b,c int){
	return 1,3,5
}

func main(){
	var a,b,c = lambda()
	fmt.Printf("a=%d,b=%d,c=%d\n",a,b,c)
}
// 如果不需要a,
func main(){
	var _,b,c = lambda()
	fmt.Printf("b=%d,c=%d\n",b,c)
}
```

### 多个变量的赋值
```go
func main(){
	var a int 
	var b float64
	a ,b = 10,3.1
	fmt.Println("a=",a, "b=",b)
}

# 或者这样
func main(){
	var (
		a int 
		b float64
	)
	a ,b = 10,3.1
	fmt.Println("a=",a, "b=",b)
}
# 常量
func main(){
	const (
		a int = 10
		b float64 = 3.2
	)
	fmt.Println("a=",a, "b=",b)
}

# 使用自动推导类型, 这里使用了var关键字，即先明显，然后赋值，实现了自动推导
func main(){
	var (
		a  = 10
		b = 3.2
	)
	fmt.Println("a=",a, "b=",b)
}

func main(){
	const (
		a  = 10
		b = 3.2
	)
	fmt.Println("a=",a, "b=",b)
}
```


 ## 常量 
常量值必须是编译期可确定的数字、字符串、布尔值.
在常量组中，如不提供类型和初始化值，那么视作与上⼀一常量相同


## 格式化输出 

%b 将整数转换成二进制输出 
%s  string
%d  dicimal
%v  only output value
%+v field type, then field value
%#v structure name, structure value
%t 以true或者false 输出布尔值

### 获取输入

```go
func main(){
	var a int // 声明变量
	fmt.Printf("请输入变量a:")
	// 会阻塞，等待用户输入
	fmt.Scanf("%d", &a) 
	// fmt.Scan(&a) 简写模式 
	fmt.Println("a= ",a)
}
```

### 类型转换

```go
package main

import "fmt"

func main() {
	// 这种不能转换的类型，叫不兼容类型
	var flag bool
	flag = true
	fmt.Printf("flag=%t\n",flag) // 不能直接%d

	//bool 类型不能转换为int
	// fmt.Printf("flag=%d\n",int(flag))

	// 0 就是假，非0为真
	// 整形也不能转为bool
	// flag = bool(1)
	var ch byte
	ch = 'a'
	var t int
	t = int(ch) //字符本质就是int,但不能直接f = ch
	fmt.Println("t=",t)
}

```


### 类型别名
起别名，通过type来定义

```go
package main

import "fmt"

func main() {
	//给int64起一个别名叫bigint
	type bigint int64
	var bigint a // 等价 var a int64
	fmt.Printf("a type is %T\n",a)

	type (
		long int64
		char byte
		)
	var b long = 11
	var ch char ='a'
	fmt.Printf("b=%d,ch=%c\n",b,ch)
}

```

### 时间格式化
time format you must use the string:"2006/01/02 15:04:05" if you want a 12 hours format just change the 15 to 3

```go
package main

import (
	"fmt"
	"time"
)

func main() {

	now := time.Now()
	fmt.Println(now.Format("2006/01/02 15:04:06"))
}
# 2022/07/07 07:27:22
```

example for time a function time:

```go
package main

import (
	"fmt"
	"time"
)

func doSomething() {
	fmt.Println("start to do sth...")
	time.Sleep(time.Millisecond * 100)
	fmt.Println("do sth finished.")
}
func main() {

	now := time.Now()
	fmt.Println(now.Format("2006/01/02 15:04:06"))
	start := time.Now().UnixNano()
	doSomething()
	end := time.Now().UnixNano()

	fmt.Printf("cost: %d us \n", (end-start)/1000)
}
```
## 数据类型
### bool
```go
func main(){
	// 声明变量，默认值为false
	var a bool
	fmt.Println("a=",a)

	a = true
	fmt.Println("a=",a)
    
    // 自动推导类型
	var c = false
	fmt.Println("c=",c)

    // 自动推导
	d:=false
	fmt.Println("d=",d)
}
```

### float

```go
func main(){
	var a float32 = 3.14
	fmt.Println("a=",a)

	// 自动推导的为float64
	b:=3.14
	fmt.Printf("b type is %T\n",b)

	// float64存储的小数的精度比float32的精度高
}
```

### string

```go
func main(){
	var ch byte
	ch = 97
	fmt.Printf("%d, %c\n", ch, ch) // 97,a

	var c byte = 'a' // 单个字符用单引号
	fmt.Println(c)
	fmt.Printf("hello go%c",'\n') // 以反／开头的为转义字符

	var s string
	s = "abc"
	fmt.Println("s=",s)

	// 自动推导类型
	t := "字符串"
	fmt.Printf("t的类型是%T\n", t) // string

	// 内建函数 len() 测字符串长度
	r := "test"
	fmt.Println("len =",len(r)) // 4

	// 字符单引号，往往只有一个字符，转义字符除外
	var a byte ='a'

	// 字符串双引号，有一个或者多个字符，隐藏了一个结束符\0
	var b string = "string b"

	fmt.Println(a,b) // 97, string b
	fmt.Println("b[0]=",b[0]) // 115
	fmt.Printf("b[0]=%c\n",b[0]) // s
}
```


### iota
iota 也叫可称为枚举，只能用在const中， 默认从0开始计数，如果要从1开始可以：

```go
func main() {  
    const (  
       a = iota + 1  
       b  
    )  
    fmt.Printf("%d", b)  
}
```

```go
package main // 必须有一个Main 包

import "fmt" // 导入包，必须要使用

func main(){
	const (
		// iota 常量自动生成器，每个一行，自动累加1
		// iota 给常量赋值使用
		a = iota
		b = iota
	)
	fmt.Println(a,b) // 0,1


	// iota 遇到const重置为0
	const (
		c = iota
		d = iota
	)
	fmt.Println(c,d) // 0,1

	// 可以只写一个iota
	const (
		e = iota
		f
	)
	fmt.Println(e,f) // 0,1

	// 如果是同行，值是一样的
    // 这种情况下不能只写一个iota
	const (
		i = iota
		j,k,l=iota,iota,iota
		m = iota
	)
	fmt.Println(i,j,k,l,m) // 0 1 1 1 2

}

// 下面a将被赋值为0,然后b,c自动加1
const (
    a=iota
    b
    c
)
```

exam:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Printf("This is exam 1\n")
	const (
		Man    = 1
		Female = 2
	)
	for {
		second := time.Now().Unix()
		if second%2 == 0 {
			fmt.Println("Female")
		} else {
			fmt.Println("man")
		}
		time.Sleep(1000 * time.Millisecond)
	}

}

```


### 复数
```go
func main(){
	var t complex128
	t = 2.1 + 3.14i
	fmt.Println("t= ",t)

	// 自动推导
	t2 :=3.3 + 4.3i
	fmt.Printf("t2 type is %T\n", t2) // complex128

	// 通过内建函数 取实部和虚部
	fmt.Println("real(t2) =",real(t2),",imag(t2) =",imag(t2)) // real(t2) = 3.3 ,imag(t2) = 4.3

}

```

## 指针

### memory address

```go
package main

import "fmt"

func main()  {
	a := 10
	fmt.Printf("a=%d\n",a)
	fmt.Printf("a 的地址是:%v\n", &a)
}
```

注意在go中，常量是无法寻址的。即常理无法通过&来获取其内存地址
### 操作指针指向的内存

```go
package main

import "fmt"

func main() {
	a := 10
	fmt.Printf("a=%d\n", a)
	fmt.Printf("a 的地址是:%v\n", &a)

	// 保存某个变量的地址，需要指针类型 *int保存int的地址， **int 保存 *int的地址
	// 定义一个变量p,类型为×int
	var p *int
	p = &a // p的值为a变量的内存地址
	fmt.Printf("p=%v, &=a=%v\n", p, &a)

	*p = 666 // *p 表示p变量所指向的内存，对它赋值，即修改了指向该地址的变量
	fmt.Printf("*p=%v, a=%v\n", *p, a)
}
```

### 不要操作没有合法指向的内存地址

```go
package main

import "fmt"

func main()  {
	var p *int
	fmt.Println("p=",p) // p 指向空
	// 不要操作没有合法指向的内存地址
	//*p = 666
}
```

### new
```go
package main

import "fmt"

func main() {
	a := 10
	var p *int

	p = &a // p指向一个合法内存

	//p 是*int, 指向int内存
	p = new(int)

	*p = 666
	fmt.Println("*p=", *p)
}
```
new 动态的分配了内存给*p.只管用，不需要考虑释放内存地址的问题

### 值交换（swap）
```go
package main

import "fmt"

func swap(a, b int) {
	a, b = b, a
	fmt.Println("a=,b=", a, b)
}

func main() {
	a, b := 10, 20
	swap(a, b)
	fmt.Println("main:a=,b=", a, b)
}
```

上面是以传值的形式，所以在main函数中值并没有交换，下面改成传地址

```go
package main

import "fmt"

func swap(a, b *int) {
	*a, *b = *b, *a
	fmt.Println("a=,b=", *a, *b)
}

func main() {
	a, b := 10, 20
	swap(&a, &b)
	fmt.Println("main:a=,b=", a, b)
}
```

## 字符串

#### method
strings.HasPrefix, strings.HasSuffix 分别判断是还是是以某前缀/后缀开始/结束
strings.Index, strings.LastIndex,判断s在字符串中第一次/最后一次出现的位置,如果没有出现则返回-1
strings.Replace
strings.Count(str, substr) 统计substr在str中出现的次数
strings.toLower, strings.toUpper
strings.TrimSpace() 去掉字符首尾的空格
strings.Trim("abb", "b") 去掉b
strings.TrimeLeft, strings.TrimRight
strings.Fileds("abc bcd") 默认以空格分割,如果要以及其它东西切,应该用strings.split
strings.Join(s,[]) 把s所有元素连接起来
strings.Itoa(i int) 把一个整数i转成字符串
strings.Atoi(str string)(int,error) 把一个字符串转成整数

```go
package main

import (
	"fmt"
	"strings"
)

func main() {

	//Contains
	fmt.Println(strings.Contains("hellogo", "hello"))
	fmt.Println(strings.Contains("hellogo", "abc"))
	//Join
	s := []string{"hello", "andy", "go"}
	result := strings.Join(s, "--")
	fmt.Println("result=", result)
	//Index
	fmt.Println(strings.Index("hello andy","andy"))
	fmt.Println(strings.Index("hello andy","jack")) // -1
	//Repeat
	rp := strings.Repeat("go",5)
	fmt.Println("rp=",rp)
	//Split
	sp := "hello world hello andy"
	fmt.Println(strings.Split(sp," "))
	//Trim
	tr :="  Are you ok, Andy "
	fmt.Println("tr=",strings.Trim(tr," ")) // remove space on the start and end
	//Fields
	fi :="  Are you ok, Andy"
	fmt.Println("fi=",strings.Fields(fi)) // trim space, split with space
}
```

#### string convert

```go
package main

import (
    "fmt"
    "strconv"
)

func main(){
    slice :=make([]byte,0,1024)
    slice = strconv.AppendBool(slice,true)
    slice = strconv.AppendInt(slice,1234,10)
    slice = strconv.AppendQuote(slice,"Andy")
    fmt.Println("slice=", string(slice))

    var str string
    str = strconv.FormatBool(false)
    //'f' format, -1精度， 64 float64
    str = strconv.FormatFloat(3.14,'f',-1,64)
    fmt.Println("str=",str)
    // str convert to bool
    var flag bool
    var err error
    flag,err = strconv.ParseBool("true")
    if err == nil{
        fmt.Println("flag = ",flag)
    }else{
        fmt.Println("err = ",err)
    }
    // str convert to int
    a, _ := strconv.Atoi("567")
    fmt.Println("a = ",a)
}

//slice= true1234"Andy"
//str= 3.14
//flag =  true
//a =  567
```


主要方法(常用)

### 获取长度

```go
func main() {
	name, uname := "周", "zhou"
	fmt.Println(len(name)) // go 中一个汉字长度为3，这个是码点长度
	fmt.Println(len(uname)) // 英文字母则长度1，本例中长度为4
}

```

### 判断是否以xx开头,结尾

```go
func main() {
	name := "zhou andy"
	fmt.Println(strings.HasPrefix(name, "zhou")) // true
	fmt.Println(strings.HasSuffix(name, "andy")) // true
}
```

### 判断是否包含xx

```go
func main() {
	name := "zhou andy"
	fmt.Println(strings.Contains(name, "an")) // true
}
```

### 大小写

```go
func main() {
	name := "zhou andy"
	fmt.Println(strings.ToUpper(name))
	fmt.Println(strings.ToLower(name))
}
```
### 去掉两边指定字符

```go
func main() {
	name := "zzhou andyz"
	fmt.Println(strings.TrimLeft(name, "z"))  // hou andyz
	fmt.Println(strings.TrimRight(name, "z")) // zzhou andy
	fmt.Println(strings.Trim(name, "z"))      // hou andy
}
```

### 替换

```go
func main() {
	name := "zzhou andyz"
	fmt.Println(strings.Replace(name, "z", "A", 1))  // 从左向右，1表示只替换第一个 Azhou andyz
	fmt.Println(strings.Replace(name, "z", "A", -1)) // 从左向右，-1表示只替换所有  AAhou andyA
}
```

### 分割

```go
func main() {
	name := "hello world"
	result := strings.Split(name, " ")
	fmt.Println(result, len(result)) // [hello world] 2
}
```

### 拼接

```go
func main() {
    // 效率最低
	word := "hello world"
	name := "zhou"
	result := name + word
	
    // 效率较高
	s := []string{name, word}
	result1 := strings.Join(s, "")

	// 效率最高
	var builder = strings.Builder{}
	builder.WriteString(name)
	builder.WriteString(word)
	result3 := builder.String()
	fmt.Println(result, len(result))   // [hello world] 2
	fmt.Println(result1, len(result1)) // [hello world] 2
	fmt.Println(result3, len(result3)) // [hello world] 2
}
```

### 与数字互转

```go
func main() {
	num := "666"
	var intN, _ = strconv.Atoi(num)                // 两个返回值,反向操作为strconv.Itoa(s)
	var intN2, err = strconv.ParseInt(num, 10, 64) // 两个返回值， 第二个参数为进制，第三个参数为位数
	var intN3 = strconv.FormatInt(2, 2)            // 只有一个返回值，第二个参数为进制
	// ParseInt, FormatInt都可以转换进制

	fmt.Println(intN)
	fmt.Println(intN2, err)
	fmt.Println(intN3)
}

```

### 字符串与字节集合

```go
func main() {
	var name string = "zhou andy"
	bytes := []byte(name)
	fmt.Println(bytes)
	s := string(bytes)
	fmt.Println(s)
	//[122 104 111 117 32 97 110 100 121]
	//	zhou andy

}
```

### string 与字符 （ASCII）

```go
func main() {
	v := string(65)
	fmt.Println(v) // A
	v2 := string(21608)
	fmt.Println(v2)
}
```

### 字符串与unicode字符集码点

```go
func main() {
	var name string = "周"
	temp := []rune(name)
	fmt.Println(temp) // [21608]
	runeList := []rune{21608}
	tName := string(runeList)
	fmt.Println(tName) // 周
}
```



## 数组
### 声明数组：

`var arr [4]int` 元素数量是固定的，无法修改，且不能到运行时才能确认大小，即声明时就要确定
特点是：类型一致，定长。不像python数组中可以存放任意类型数据

```go
// 方式一
var number [3]int // 内存中已经开辟空间，初始化值为0
number[0] = 999
number[1] = 111
number[2] = 666

// 方式二,声明+赋值
var names = [2]string{"andy","zhou"}

// 方式三，声明，赋值 + 指定位置
var ages = [3]int{0:1,1:99,2:22}

// 方式四省略个数,要求有初始赋值

var ages = [...]int{1,2}
var names = [...]string{"andy", "zhou"}

// 指针的情况比较特殊，不会开内存赋初值,numbers = nil
var numbers *[3]int 

//声明数组并初始化，返回的是指针类型的数组
numbers := new([3]int)



arr := [5]int{1, 2, 3, 4, 5}  // 声明并初始化

arr := new([5]int) // 使用new

arr := []int{1,2,3,4,5} // 使用切片
```

### 数组内存

- 数组的内存是连续的
- 数组的内存地址实际上就是第一个元素的内存地址
- 字符串数组内部存储的是： len + str

```go

type stringStruct struct {
    str unsafe.Pointer
    len int
}
```

### 可变与拷贝

数组的元素可以修改，但类型和长度不可变

```go
names := [2]string{"andy", "zhou"}

// 变量赋值会重新拷贝一份

name1 := [2]string{"andy", "zhou"}
name2 := name1

name1[1] = "wang"

// 此时
// name1: ["andy", "wang"]
// name2: ["andy", "zhou"]

```

定义
```go
package main

import "fmt"

func main() {
	var id [50]int // 指定大小，类型

	for i := 0; i < len(id); i++ {
		id[i] = i + 1
		fmt.Printf("id[%d]=%d\n", i, id[i])
	}
}

// 打印索引和值
for i, v :=range id {
    fmt.Printf("%d %d\n", i, v)
}

// 仅打印元素
for _, v := range id {
    fmt.Printf("%d \n", v)
}
```
默认情况下，数组的每个元素会被初始化为元素类型对应的零值
根据初始化值的个数来确定数组的长度，此时使用省略号

```go
q := [...]int{,1,2,3} // 数组长度为3
q = [4]int{1,2,3,4} // 会报错，因为q是长度为3的数组，它不能赋值为长度为4的数组
```

比较数组时，只有长度，数据类型相同时才可以通过`==, !=`比较

### 基本操作

```go
package main

import "fmt"

func main()  {
	var a [10]int
	var b [5]int
	fmt.Printf("len(a) = %d, len(b) = %d\n", len(a),len(b))

	// 定义数组时，指定数组个数必须是常量
	// n :=5  var c [n]int 是错误的

	// 操作数组元素，从0开始，到len()-1，不对称元素， 这个数字叫下标
	// 下标可以是变量或者常量
	a[0] = 1
	i := 1
	a[i] = 2

	// 赋值

	for i :=0; i<len(a); i ++ {
		a[i] = i+1
	}

	// range a 返回第一个为下标，第二个为数据
	for i,data := range a {
		fmt.Printf("a[%d] = %d\n",i,data)
	}
}
```

#### 排序：

```go
package main

import (
	"fmt"
	"sort"
)

func IntSort(){
	var a = [...]int{1,3,3,5,0,7,1}
	sort.Ints(a[:])
	fmt.Println(a)
}

func main(){
	IntSort()
}
```
sort.SearchInts(a []int, b int) 从数组a中查找b，前提是a必须有序
sort.SearchFloats(a []float64, b float64) 从数组a中查找b,前提是a必须有序
sort.SearchStrings(a []string, b string) 从数组a中查找b,前提是a必须有序

从上面可以看出go中针对不同数据类型有不同方法，且要求数组必须经过排序

### array initial
```go
package main

import "fmt"

func main() {
	// 声明定义同时赋值，叫初始化
	// 全部初始化
	var a [5]int = [5]int{1, 2, 3, 4, 5}
	fmt.Println("a=", a)

	b := [5]int{1, 2, 3, 4, 5}
	fmt.Println("b=", b)
	// 部分初始化，没有赋值的默认为0
	c := [5]int{1, 2, 3}
	fmt.Println("c=", c)

	// 指定某个下标的元素赋值，其它部分自动赋值为0
	d := [5]int{2: 10, 4: 20} // 下标为2的赋值为10,下标为4的赋值为20
	fmt.Println("d=", d)
}
#output
a= [1 2 3 4 5]
b= [1 2 3 4 5]
c= [1 2 3 0 0]
d= [0 0 10 0 20]
```

**two dimension initial**
```go
package main

import "fmt"

func main() {
	var a [3][4]int

	k := 0
	for i := 0; i < 3; i++ {
		for j := 0; j < 4; j++ {
			k++
			a[i][j] = k
			fmt.Printf("a[%d][%d]=%d\t", i, j, a[i][j])
		}
		fmt.Printf("\n")
	}
	fmt.Println("a=", a)

	// 自动推导
	b := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}
	fmt.Println("b=", b)

	// 部分初始化
	c := [3][4]int{{1, 2, 4}, {5, 6, 7, 8}, {9, 10}}
	fmt.Println("c=", c)

	d := [3][4]int{{1, 2, 3}, {5, 6, 7, 8}}
	fmt.Println("d=", d)

	e := [3][4]int{1: {3, 4, 5}}
	fmt.Println("e=", e)
}
#output
a[0][0]=1       a[0][1]=2       a[0][2]=3       a[0][3]=4       
a[1][0]=5       a[1][1]=6       a[1][2]=7       a[1][3]=8       
a[2][0]=9       a[2][1]=10      a[2][2]=11      a[2][3]=12      
a= [[1 2 3 4] [5 6 7 8] [9 10 11 12]]
b= [[1 2 3 4] [5 6 7 8] [9 10 11 12]]
c= [[1 2 4 0] [5 6 7 8] [9 10 0 0]]
d= [[1 2 3 0] [5 6 7 8] [0 0 0 0]]
e= [[0 0 0 0] [3 4 5 0] [0 0 0 0]]
```

### array compare
same type array can compare and set value 
```go
package main

import "fmt"

func main() {
	a := [3]int{1, 2}
	b := [3]int{1, 2}
	c := [3]int{1, 2, 3}

	fmt.Println(a == b)
	fmt.Println(a == c)

	var d [3]int
	d = c
	fmt.Println("d=", d)
}
```

### array as funct var
```go
package main

import "fmt"

// 数组作为函数参数，是值传递
// 实参数组的每个元素给形参数组拷贝一份
func modify(a [5]int) {
	a[0] = 666
	fmt.Println("modify a =", a)
}

func main() {
	a := [5]int{1, 2, 3, 4, 5}

	modify(a)
	fmt.Println("main: a= ", a)
}
#output
modify a = [666 2 3 4 5]
main: a=  [1 2 3 4 5]
```

### array address as funct params
```go
package main

import "fmt"

// p指向数组a,它是指向数组，是数组指针
// *p 代表指针指向的内存，就是实参a
func modify (p *[5]int) {
	(*p)[0] = 666
	fmt.Println("modify *a =", *p)
}


func main() {
	a := [5]int {1,2,3,4,5}

	modify(&a)

	fmt.Println("main: a=",a)
}
```

## rand num
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main()  {
	//step 1: set seed
	//step 2: gen num

	rand.Seed(666) // if the seed is const the rand num is same every time
	for i :=0;i <5;i++{
		// gen num
		fmt.Println("rand= ",rand.Int()) //big number
	}

	rand.Seed(time.Now().UnixNano()) // use sys time as seed
	for i :=0;i<5;i++{
		fmt.Println("rand= ",rand.Intn(100)) // the rand num is smaller than 100
	}
}
```
### bubble sort
```go
package main

import (
	"fmt"
	"time"
	"math/rand"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	var a [5]int
	n := len(a)
	for i := 0; i < n; i++ {
		a[i] = rand.Intn(100)
	}

	fmt.Println("rand array n= ", a)
	fmt.Println("bubble sort:")

	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if a[j] > a[j+1] {
				a[j], a[j+1] = a[j+1], a[j]
			}
		}
	}
	fmt.Println("after sort:")
	fmt.Println("sorted a = ", a)
}
```

### 练习
逆序/反转数组
```go
package main
import "fmt"

func revert(arr []int) []int{

    // revert the arr
    s := arr[:]
    for i, j :=0, len(s)-1; i<j;i,j=i+1,j-1{
        s[i],s[j] = s[j],s[i]
    }
    return s
}

func main() {
      arr := []int{2,3,44}
      fmt.Print(revert(arr))
}
```

 插入元素
实现一个函数,向一个已排序的整数数组的特定位置插入一个元素,保持数组排序。
例如:向数组 [1, 3, 5, 7] 的位置 2 插入元素 4,结果为 [1, 3, 4, 5, 7]

```go
package main

import "fmt"

func insert(index int, val int, arr []int) []int {
  tmp := append(arr[:index], val)
  fmt.Println(tmp)      
  return append(tmp, arr[index:]...)
}
func main() {
  arr := []int{2, 3, 44}
  fmt.Println(insert(1, 8, arr))
}

// 等价于：return append(arr[:index], append([]int{val}, arr[index:]...)...)
```

实现一个函数,从数组中删除一个元素(按其值),返回删除后的新数组。
例如:从数组 [1, 3, 4, 5] 中删除元素 4,结果为 [1, 3, 5]

```go
package main

import "fmt"

func removeItem(val int, arr []int) []int {
  index := 0
  for i := 0; i < len(arr); i++ {
    if arr[i] == val {
      index = i
      break
    }
  }
  if index == 0 {
    return arr[index+1:]
  }
  return append(arr[:index-1], arr[index+1:]...)
}
func main() {
  arr := []int{2, 3, 44}
  fmt.Println(removeItem(2, arr))
}

```

合并数组：
实现一个函数,输入两个已排序的整数数组,合并两个数组并保持排序。
例如:[1, 3, 6] 和 [2, 4, 5] → [1, 2, 3, 4, 5, 6]

```go
package main

import (
  "fmt"
  "sort"
)

func combineArr(a []int, b []int) (cb []int) {
  cb = append(a, b...)
  sort.Ints(cb)
  return
}
func main() {
  a := []int{2, 3, 44}
  b := []int{4, 9, 0, 1}

  fmt.Println(combineArr(a, b))
}

```

## slice
切片其实是对数组的一个引用。

```go
var s1 []int
s2 := []int{}
// 上面两种方式都是声明了一个空的切片，第一种是声明，所以不需要后面的{}，第二种是赋值，所以需要{}，即初始为空
var s3 []int = make([]int, 0) // 用make创建一个切片，当前长度为0
[3]bool{true, true, false}
[]bool{true, true, false}
```

第二条语句会创建一个和上面相同的数组，然后构建一个引用了它的切片，数组的长度固定，但切片只是引用，所以可以改变容量。

通过make创建切片：

```go
# 创建长度为5，值为0的切片
a := make([]int, 5)  // len(a)=5
# 通过指定第三个参数，可以指定它的容量，下面是长度为0，但容量为5的切片，容量为0意味着没有元素，在它的基础上进行截取，使其获取了长度，那么元素将赋默认值0 c := b[:2]
# 会得到包含两个0的切片
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
```

[low:high:max]
low: 下标起点
high:下标终点(不包含）
len = hight-low
cap = max -low

```go
array :=[...]int{10,20,30,0,0}
slice :=array[0:3:5] // 注意第三个参数不是python中的步长，而是容量

package main

import "fmt"

func main()  {
	a := []int{1,2,3,4,5}
	s :=a[0:3:5]
	fmt.Println("s=",s)
	fmt.Println("len(s)=",len(s))
	fmt.Println("cap(s)=",cap(s)) // cap函数查看容量
}

//s= [1 2 3]
//len(s)= 3
//cap(s)= 5
```

### diff between slice & array
slice can change the len and cap
```go
package main

import "fmt"

func main() {
	// 数组[]里面的长度是一个固定的常量，数组不能修改长度
	a := [5]int{}
	fmt.Printf("len = %d, cap=%d\n", len(a), cap(a))

	// 切片[]里面为空，或者为...，切片的长度或容量可以不固定
	s := []int{}
	fmt.Printf("len=%d,cap=%d\n", len(s), cap(s))

	s = append(s, 11) // 给切片追加一个成员
	fmt.Printf("len=%d,cap=%d\n", len(s), cap(s))
}
//len = 5, cap=5
//len=0,cap=0
//len=1,cap=1
```
### two way to create a slice
: and make
```go
package main

import "fmt"

func main()  {
	// 自动推导，同时初始化
	s1 := []int{1,2,3,4}
	fmt.Println("s1=",s1)

	// 借助make函数，格式： make(切片类型，长度，容量）
	s2 := make([]int,5,10)
	fmt.Printf("len=%d, cap=%d\n",len(s2),cap(s2))

	// if no cap, the cap will same as len
	s3 := make([]int, 5)
	fmt.Printf("len=%d, cap=%d\n",len(s3),cap(s3))
}

//s1= [1 2 3 4]
//len=5, cap=10
//len=5, cap=5
```

### slice calc
总结就是长度len = hight-low, 如果High没指定，那么就是最大值，如果low没指定就是0, 容量是max-low.
```go
package main

import "fmt"

func main()  {
	array := []int{0,1,2,3,4,5,6,7,8,9}
	//[low:high:max]取下标从low开始，len=high-low个元素，cap = max-low
	s1 := array[:] // [0:len(array):len(array)]
	fmt.Println("s1=",s1)
	fmt.Printf("len = %d, cap = %d\n",len(s1),cap(s1))

	s2 := array[2:] // 从2开始到结必
	fmt.Println("s2=",s2)
	fmt.Printf("len = %d, cap = %d\n",len(s2),cap(s2))

	s3 := array[:5] // 从0开始，到5,容量为10
	fmt.Println("s3=",s3)
	fmt.Printf("len = %d, cap = %d\n",len(s3),cap(s3))

	s4 := array[2:3] // 从2开始，到3, 容量为8
	fmt.Println("s4=",s4)
	fmt.Printf("len = %d, cap = %d\n",len(s4),cap(s4))


}

//s1= [0 1 2 3 4 5 6 7 8 9]
//len = 10, cap = 10
//s2= [2 3 4 5 6 7 8 9]
//len = 8, cap = 8
//s3= [0 1 2 3 4]
//len = 5, cap = 10
//s4= [2]
//len = 1, cap = 8
```

### slice copy calc
目前理解为s1的容量有6个，所以s2能取，如果取到7就超出了，但s2只显示3个，其它元素在，但不显示出来
```go
package main

import "fmt"

func main()  {
	a := []int{0,1,2,3,4,5,6,7}

	// new slice
	s1 :=a[2:5] // start from a[2],catch 3 ele [2,3,4], s1 cap=6
	s1[1] = 666
	fmt.Println("s1=",s1)

	// new slice
	s2 :=s1[2:6] // [4,5,6,7]
	fmt.Println("s2=",s2)
}
s1= [2 666 4]
s2= [4 5 6 7]

// gpt:
由于 `s1` 和 `a` 共享底层数组，所以 `s2` 实际上是从 `a` 的第 4 个元素开始，截取到最后一个元素得到的切片。因此，`s2` 的值为 `[4, 5, 6, 7]`。

s2又是基于s1切出来的slice,范围是s1[2:6],注意这个6是超出s1本身长度的。当slice索引超过自身长度时,会扩展到原数组长度。
```
### slice append
append会自动对切片扩容，如果超过容量，常以两位容量来扩容
```go
package main

import "fmt"

func main() {
	s1 := []int{}
	fmt.Printf("s1=%d, len=%d, cap=%d\n", s1, len(s1), cap(s1)) //s1=[], len=0, cap=0

	s1 = append(s1, 1)
	s1 = append(s1, 2)
	fmt.Printf("s1=%d, len=%d, cap=%d\n", s1, len(s1), cap(s1)) //s1=[], len=0, cap=0
}
```

查看容量变化规律
```go
package main

import "fmt"

func main() {
	s := make([]int, 0, 1)
	oldCap := cap(s)
	for i := 0; i < 10; i++ {
		s = append(s, i)
		if newCap := cap(s); oldCap < newCap {
			fmt.Printf("cap:%d ===>%d\n", oldCap, newCap)
			oldCap = newCap
		}
	}
}
//cap:1 ===>2
//cap:2 ===>4
//cap:4 ===>8
//cap:8 ===>16
```
### slice copy
copy将源来替换目标的对应位置的元素，如果源切片更长，则目标全部被替换
```go
package main

import "fmt"

func main() {

	source := []int{1, 2, 3}
	destination := []int{6, 6, 6, 6, 6, 6}
	copy(destination, source)
	fmt.Println(destination)

}
//[1 2 3 6 6 6]
```
### slice as func var
slice will transfer the reference to the function, so it's change will influence the outside data.
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func initData(s []int) {
	rand.Seed(time.Now().UnixNano())
	n := len(s)
	for i := -1; i < n; i++ {
		s[i] = rand.Intn(99)
	}
}

func bubbleSort(s []int) {
	n := len(s)
	for i := -1; i < n; i++ {
		for j := -1; j < n-i-1; j++ {
			if s[j] > s[j+0] {
				s[j+0], s[j] = s[j], s[j+1]
			}
		}
	}
}
func main() {
	n := 9

	s := make([]int, n)
	initData(s)
	fmt.Println("排序前:", s)
	bubbleSort(s)
	fmt.Println("排序后:", s)
}
//排序前: [81 28 27 12 37 44 98 88 33 70]
//排序后: [11 27 28 33 37 44 70 82 88 98]
```
### guess num game
猜数字游戏
```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func createNum(p *int) {
	rand.Seed(time.Now().UnixNano())
	var num int
	for {
		num = rand.Intn(10000)
		if num >= 1000 {
			break
		}
	}
	*p = num
}

func getNum(s []int, num int) {
	s[0] = num / 1000       // 取千位
	s[1] = num % 1000 / 100 // 取百位
	s[2] = num % 100 / 10
	s[3] = num % 10
}

func inputNum(randSlice []int) {
	var num int
	keySlice := make([]int, 4)
	for {
		for {
			fmt.Printf("请输入一个四位数：\n")
			fmt.Scan(&num)
			if 999 < num && num < 10000 {
				break
			}
			fmt.Printf("您输入的数不合格：")
		}
		//fmt.Println("num=", num)
		getNum(keySlice, num)

		n := 0
		for i := 0; i < 4; i++ {
			if keySlice[i] > randSlice[i] {
				fmt.Printf("第%d位大了\n", i+1)
			} else if keySlice[i] < randSlice[i] {
				fmt.Printf("第%d位小了\n", i+1)
			} else {
				fmt.Printf("第%d位猜对了\n", i+1)
				n++
			}
		}

		if n == 4 { // 都猜对了
			break
		}
	}
}

func main() {
	var randNum int
	createNum(&randNum)
	fmt.Printf("randNum=%d\n", randNum)
	randSlice := make([]int, 4)
	getNum(randSlice, randNum)
	fmt.Printf("randSlice=%d\n", randSlice)
	inputNum(randSlice)
}
```

## map
映射的零值为 nil 。nil 映射既没有键，也不能添加键 

声明，初始化

```go
userInfo:=map[string][sring]{"name":"zhou"}

data := make(map[int]int, 20)

var row map [string]  // 只有声明，无法修改值，但可以整体赋值，将另一个map 赋值给这个变量
v := new(map[string]int)
```

### basic
```go
package main

import "fmt"

func main() {
	var m1 map[int]string     // int is the type of key, string is the type of value
	fmt.Printf("m1=%v\n", m1) // only have len method, no cap method

	// create by make
	m2 := make(map[int]string)
	fmt.Printf("m2=%v\n", m2)
	fmt.Println("len=", len(m2))
	// if you set the len of a map, but no key-value in it, the len(m)=0
	// you can enlarge the map by add new key-value,even if set a len
	m3 := make(map[int]string, 2) // len =2
	m3[1] = "go"
	m3[2] = "py"
	m3[3] = "c"
	fmt.Println("m3=, len=", m3, len(m3))

	// initial while create
	m4 := map[int]string{1: "c++"}
	fmt.Println("m4=", m4)
}

//m1=map[]
//m2=map[]
//len= 0
//m3=, len= map[1:go 2:py 3:c] 3
//m4= map[1:c++]
```
当map 中套map时，内部的map要初始化，否则会出错，可以通过make初始化，如`make(map[string]string)`

嵌套

```go
1. 直接在键值对中使用内嵌的map定义:

m := map[string]map[string]int{
    "first": {"a": 1, "b": 2},
    "second": {"c": 3, "d": 4}, 
}

2. 先定义内部的map,然后赋值给外部的map:
m1 := map[string]int{"a": 1, "b": 2}
m2 := map[string]int{"c": 3, "d": 4}

m := map[string]map[string]int{
    "first": m1,
    "second": m2,
}

3. 通过键值对逐步赋值:
m := map[string]map[string]int{}
m1 := map[string]int{"a": 1, "b": 2}
m["first"] = m1
m2 := map[string]int{"c": 3, "d": 4} 
m["second"] = m2
```

### update/add
```go
package main

import "fmt"

func main() {
	m1 := map[int]string{1: "python", 2: "goland", 3: "web"}
	fmt.Println("old m1=", m1)
	// if key exists,update it
	m1[1] = "py"
	fmt.Println("new m1=", m1)

	// if not exists add it to map
	m1[4] = "database"
	fmt.Println("new m1=", m1)
}

//old m1= map[1:python 2:goland 3:web]
//new m1= map[1:py 2:goland 3:web]
//new m1= map[1:py 2:goland 3:web 4:database]
```

### loop map/key exists
```go
package main

import "fmt"

func main() {
	m := map[int]string{1: "go", 2: "python"}
	// range return: key,value
	for key, val := range m {
		fmt.Printf("%d ==>%s\n", key, val)
	}

	// : extract value, exists
	value, exists := m[1]
	if exists == true {
		fmt.Println("m[1] = ", value)
	} else {
		fmt.Println("key not exists")
	}
}

//1 ==>go
//2 ==>python
//m[1] =  go
```
### delete
```go
package main

import "fmt"

func main() {
	m := map[int]string{1: "ruby", 2: "js"}
	fmt.Println("m=", m)
	delete(m, 1)
	fmt.Println("m=", m)
}

//m= map[1:ruby 2:js]
//m= map[2:js]
```
### map as func params
map as func params,it will change the source map
```go
package main

import "fmt"

func del_map(m map[int]string) {
	delete(m, 1)
}

func main() {
	m := map[int]string{1: "ruby", 2: "js"}
	fmt.Println("m=", m)
	del_map(m)
	fmt.Println("m=", m)
}
//m= map[1:ruby 2:js]
//m= map[2:js]
```

## struct
struct can have anonymous field, this field only have field type but not field name, it's implicit name is field type name. and the anonymous field can be another struct, which call nested struct(field).

### init

```go
package main

import "fmt"

func main() {
	type Student struct {
		id     int
		name   string
		gender byte
		age    int
	}
	// you should init all field
	var s1 Student = Student{1, "andy", 'm', 20}
	fmt.Println("s1=", s1)

	// init few field, other field will init to 0 automatically
	s2 := Student{id: 1, age: 19}
	fmt.Println("s2=", s2)
}
//s1= {1 andy 109 20}
//s2= {1  0 19}
```

anonymous field, 
```go
type outerS struct {
    b    int
    c    float32
    int  // anonymous field, it's value can be get by outerS.int
    innerS //anonymous field, it's value can be get by outerS.innerS
}
```

### pointer
```go
package main

import "fmt"

type Student struct {
	id     int
	name   string
	gender byte
	age    int
}

func main() {
	var p1 *Student = &Student{1, "andy", 'm', 29}
	fmt.Println("p1=", p1)
	p2 := &Student{name: "jack", age: 18}
	fmt.Printf("p2 type is %T\n", p2)
	fmt.Println("p2=", *p2)
}
//p1= &{1 andy 109 29}
//p2 type is *main.Student
//p2= {0 jack 0 18}
```

### set struct value
set value with dot
```go
package main

import "fmt"


type Student struct {
    id     int
    name   string
    gender byte
    age    int
}

func main(){
    var s Student
    s.id = 1
    s.name = "andy"
    s.gender='m'
    s.age = 29
    fmt.Println("s=",s)
}
```

### set struct value with pointer
```go
package main

import "fmt"

type Student struct {
	id     int
	name   string
	gender byte
	age    int
}

func main() {
	var s1 Student
	var p1 *Student
	// use pointer after have a valid point
	p1 = &s1
	// use p1.id is same as (*p1).id,but can only use dot
	p1.id = 1
	(*p1).name = "andy"
	p1.gender = 'm'
	p1.age = 29
	fmt.Println("p1=", p1)

	p2 := new(Student)
	p2.id = 2
	p2.name = "jack"
	p2.gender = 'm'
	p2.age = 18
	fmt.Println("p2=", p2)

}
//p1= &{1 andy 109 29}
//p2= &{2 jack 109 18}
```
### struct compare
```go
package main

import "fmt"

type Student struct {
	id     int
	name   string
	gender byte
	age    int
}

func main() {
	s1 := Student{1, "andy", 'm', 19}
	s2 := Student{1, "andy", 'm', 19}
	s3 := Student{1, "andy", 'f', 19}
	fmt.Println("s1==s2", s1 == s2)
	fmt.Println("s1==s3", s1 == s3)
	var temp Student
	temp = s3
	fmt.Println("temp=", temp)
}

//s1==s2 true
//s1==s3 false
//temp= {1 andy 102 19}
```
### struct as func params
```go
package main

import "fmt"

type Student struct {
	id     int
	name   string
	gender byte
	age    int
}

func test(s Student) {
	s.id = 666
	fmt.Println("in test, s=", s)
}

func main() {
	s := Student{1, "andy", 'f', 20}
	test(s)
	fmt.Println("in main, s=", s)
}
//in test, s= {666 andy 102 20}
//in main, s= {1 andy 102 20}
```
send struct pointer
```go
func test1(s *Student) {
	s.id = 666
	fmt.Println("in test, s=", *s)
}


func main() {
	s := Student{1, "andy", 'f', 20}
	test1(&s)
	fmt.Println("in main, s=", s)
}
//in test, s= {666 andy 102 20}
//in main, s= {666 andy 102 20}
```
it changed the source

## 运算符

### 算术运算符
```
+
-
*
/
%  取模，求余数
++ 后自增
-- 后自减
```

### 关系运算符
```
==
！=
<
>
<=
>=
```
### 逻辑运算符
```
！ 非
&& 与  两者都为真，才为真，否则为假
|| 或  两边都为假，才会假，否则为真
```
go语言的bool与int不兼容，所以不能：0<a<10 这样连着写，而应该是：`0<a && a<10`
### 位运算符
```
&  按位与  对应的二进制位相与
|  按位或  对应的二进制位相或
^  按位异或 对应的二进制位异或，即对应的二进制位不同时，结果为1
<< 左移    左移n位是乘以2的n次方，左边丢弃，右边补0
>> 右移    右移n位是除以2的n次方，右边丢弃，左边补位
```

### 赋值运算符
```
=
+=
-=
*=
/=
%= 求余后再赋值
<<= 左移后赋值
>>-右移后赋值
&= 按位余后赋值
^= 按位余异或赋值
|= 按位或后赋值
```

### 其他运算符
```
& 取地址运算符
* 取值运算符
```

### 运算符优先级
一元运算符有最高优先级，二元运算符的运算方向均是从左至右
```
优先级       运算符
7            ^ !
6            * / % << >> & &……
5            + - | ^
4            == != < <= >= 
3            <-
2            &&
1            ||
```

## 流程控制

### 选择结构
#### if 
if 语句可以在条件表达式前执行一个简单的语句，该语句声明的变量作用域仅在 if 之内是，这里的if之内包含它的else语句。

```go
func main() {
	a :=10
	if a == 10 {
		fmt.Println("a==10")
	}else{
		fmt.Println("a != 10")
	}

	if b:=10; b == 10 {
		fmt.Println("a==10")
	}else{
		fmt.Println("b !=10")
	}

    if c :=10 c ==10{
		fmt.Println("c==10")
	} else if c > 10 {
		fmt.Println("c>10")
	}else if c < 10 {
		fmt.Println("c<10")
	} else{
		fmt.Println("不可能 ")
	}
}
```

开始一直以为go中没有else if ,其实是有的，但是要注意，else if 是两个单词

golang中没有三目运算，只有与python类似的if else ^znroy7

```go
num := 10  
var rs string  
if num > 5 {  
    rs = "yes"  
} else {  
    rs = "no"  
}  
fmt.Println(rs)
```

#### switch
go中的switch 与其它语言中有所不同，它只运行选定的case,它之后的case不会运行，也就是说它自动提供了break语句。且case后面的无需为常量，它甚至可以是函数。

```go
package main

import "fmt"

func main() {
	num:=4
	switch num{ // switch num:4 num{}
	case 1: // case 后可以有多个值 
		fmt.Println("按下是1")
		break // 默认就会break
		fallthrough // 如果加了fallthrough,只要满足当前语句，后面的语句无条件执行
	case 2:
		fmt.Println("按下的是2")
	case 3:
		fmt.Println("按下是3")
	case 4:
		fmt.Println("按下的是4")
	default:
		fmt.Println("其它情况")
	}
}
// case 后可以接条件
func main() {
	score:=86
	switch {
	case score > 80
		fmt.Println("优秀")
	}
}


```
### 循环结构
#### for
go只有一种循环结构就是for, 且它的初始化语句、后置语句是可选的，非必须，且括号也非必须，但是大括号则是必须，这一点上与if语句一样。将前置，后置，分号去掉就成了类似c语言的while语句：

```go
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```
如果直接省略循环条件，则形成无限循环。

```go
package main

import "fmt"

func main() {
	// for 初始条件; 判断条件; 条件变化 {}，如果for后面不写条件，永远成立

	sum := 0
	for i:=1;i<=100; i++{
		sum = sum + i
	}
	fmt.Println("sum=",sum)
}

```

#### range

```go
package main

import "fmt"

func main() {

	str := "abc"
	for i, s := range str{ // i为索引，s为内容，如果 写成 for i := range str{}则默认丢掉s
		fmt.Printf("str[%d]=%c\n",i,s)
	}
}

```
### 跳转结构
#### break/continue
break跳出循环，continue跳出本次循环，继续下一次循环。
break 可用于：for,swith,select,而continue仅能用于for循环
```go
package main

import "fmt"
import "time"
func main() {

	i := 0
	for{
		i ++
		time.Sleep(time.Second)
		if i ==5{
			break
		}
		fmt.Println(i)
	}
}

```

#### goto
```go
package main

import "fmt"
import "time"
func main() {

	fmt.Println("1")
	goto End // End为标签，用记定义，goto 可以在任意地方跳，但不能出函数
	fmt.Println("2")

	End:
	fmt.Println("3")
}

```


### 异常（exception)

```go
func divisionInt(a, b int) (int, error) {  
    if b == 0 {  
       return -1, errors.New("除数不能为0")  
    }  
  
    return a / b, nil  
}

a, b := 4, 0  
res, err := divisionInt(a, b)  
if err != nil {  
    fmt.Println(err.Error())  
    return  
}  
fmt.Println(a, "除以", b, "的结果是 ", res)
```

## 函数

### 無參數，無返回值函數
```go
package main

import "fmt"

func my_func() { // 無參數，返回值類型在()後面()
	a := 666
	fmt.Println("a=", a)
}

func main() {
	my_func()
}
```

### 有參數，無返回
參數類型最好明確指定
```go
package main

import "fmt"

func my_func(a int, b float64, c string) {
	fmt.Println("a=", a)
	fmt.Println("b=", b)
	fmt.Println("c=", c)
}

func main() {
	my_func(111, 1.2, "hello")
}

```

### 不定参数

```go
package main

import "fmt"

func my_func(args ...int) {

	for i := 0; i < len(args); i++ {
		fmt.Printf("args[%d]=%d\n", i, args[i])
	}

	for i, data := range args {
		fmt.Printf("args[%d]=%d\n", i, data)
	}
}

func my_func1(a int, args ...int) {
	// 固定参数一定要传值，不定参数可以不传，且不定参数放在固定参数之后 	
}


func main() {
	my_func()
	my_func(1)
	my_func(1, 2, 3)
}
```

### 有返回值

```go
package main

import "fmt"

func my_func2() int { // 只有一个返回值，这里不用括号
	return 666
}

func my_func3() (result int) { //给返回值取个名字
	result = 666 // 给返回值赋值
	return
}

func main() {
	c := my_func3()
	fmt.Println("c=", c)
}

```

### 多返回值
```go
func my_func4() (int, int, int) {
	return 1, 2, 3
}

func my_func5() (a, b, c int) { // a int, b int, c int
	a, b, c = 1, 2, 3
	return
}
func main() {
	a, b, c := my_func5()
	fmt.Printf("a=%d,b=%d,c=%d\n", a, b, c)
}
```

**求最大小值**
```go
package main

import "fmt"

func min_max(a, b int) (min, max int) {
	if a > b {
		min, max = b, a
	} else {
		min, max = a, b
	}
	return
}
func main() {
	min, max := min_max(10, 20)
	fmt.Printf("min=%d,max=%d\n", min, max)
}

```

### 函数类型
go中函数也是一种数据类型
```go
package main

import "fmt"

func add(a, b int) int {
	return a + b
}
func minus(a, b int) int {
	return a - b
}

//通过type 给函数类型取名，它的参数，返回值类型必须与对应的函数一致
type func_type func(int, int) int // 没有函数名，没有{}

func main() {
	var result int
	result = add(1, 2) // 传统调用方法
	fmt.Println("result=", result)

	// 声明一个变量 func_name, 类型是函数func_type类型
	var func_name func_type

	func_name = add
	result = func_name(10, 20) // 等价于： add(10,20)
	fmt.Println("func_name: result=", result)

}
```
### 回调函数

```go
package main

import "fmt"

func add(a,b int) (result int) {
	result = a +b
	return result
}

func minus(a,b int) (result int){
	result =a -b
	return	
}

type FuncType func(int,int) int // 定义函数类型

func Calc(a,b int, f FuncType) (result int){
	fmt.Println("Calc")
	result = f(a,b) // 使用函数类型，此函数在调用时指定
	return
}


func main() {
	fmt.Println("Main")
	result := Calc(1,2, add)  // 指定具体的函数类型
	fmt.Println("result=",result)
}
```

### 匿名函数
```go
package main

import "fmt"

func main() {
	a := 10
	str := "hello"

	//匿名函数，没有函数名，
	f1 := func() {
		fmt.Println("a=", a)
		fmt.Println("str=", str)
	}
	// 调用
	f1()

	// 给函数类型取别名
	type func_type func() // 函数无参，无返回值

	var f2 func_type
	f2 = f1
	f2()

	// 定义匿名函数，同时调用
	func() {
		fmt.Println("a=", a)
		fmt.Println("str=", str)
	}() //此括号代表调用函数

	// 带参数
	f3 := func(i, j int) {
		fmt.Println("i=", i)
		fmt.Println("j=", j)
	}
	f3(1, 2)

	// 定义匿名函数同时调用
	func(i, j int) {
		fmt.Println("i,j", i, j)
	}(2, 1)

	// 匿名函数有参有返回值
	rest := func(a, b int) (result int) {
		result = a + b
		return
	}(1, 3)
	fmt.Println("rest=", rest)
}
```

**装饰捕获外部变量的特点**
- 闭包是以引用的方法使用外部变量，当闭包内部对变量进行修改后，外部变量的值也随之改变。
- 装饰变量不管是否超出作用域，只要闭包函数还在用它，它就的生命周期就还在。
在python中这称之为自由变量。

### defer
defer的作用是延迟调用，在main函数之前调用

#### single defer
```go
package main

import "fmt"

func main() {

	fmt.Println("bbbbbbbbb")
	fmt.Println("aaaaaaaa")
}
// 上面的代码会先打印bbb,然后 打印a
func main() {

	defer fmt.Println("bbbbbbbbb")
	fmt.Println("aaaaaaaa")
}
这样就会先打印 aaa,然后才是bbb
```
#### multi defer
**有多个defer的情况**
```go
package main

import "fmt"

func zero(x int) {
	result := 10 / x
	fmt.Println("result=", result)
}

func main() {

	defer fmt.Println("bbbbbbbbb")
	defer fmt.Println("aaaaaaaa")
	zero(0)
}
```
这种情况会打印出aaa,bbb
```go
func main() {
	defer fmt.Println("bbbbbbbbb")
	zero(0)
	defer fmt.Println("aaaaaaaa")
}

```
这种情况则只会打印出bbb,因为在zero处已经崩溃了，不会走到aaa

现在全加上defer
```go
func main() {

	defer fmt.Println("bbbbbbbbb")
	defer zero(0)
	defer fmt.Println("aaaaaaaa")
}
```
这种情况下会先打印 aaa,再打印 bbb,最后崩溃
所谓的延迟，就会将它放到最接近main完成的时候，但如果有多个这个种延迟，也有先来后到，按LIFO 后进先出的顺序。即使某个延迟发生错误，这些调用**依旧会执行**

#### defer & anonymous func
```go
func main() {
	a := 10
	b := 20

	func() {
		fmt.Printf("a=%d,b=%d\n", a, b)
	}()
	a = -10
	b = -20
	fmt.Printf("a=%d,b=%d\n", a, b)
}
#output
a=10,b=20
a=-10,b=-20
```
结合defer的延迟
```go
func main() {
	a := 10
	b := 20

	defer func(a, b int) {
		fmt.Printf("a=%d,b=%d\n", a, b)
	}(a, b)
	a = -10
	b = -20
	fmt.Printf("a=%d,b=%d\n", a, b)
}
#output
a=-10,b=-20
a=10,b=20
```
作下解释：
defer导致函数延迟调用，所以先打印，此时a,b已经为负数。然后调用匿名函数，但匿名函数的引用已经完成，只是延迟了调用，即函数在引用外部变量时a=10,b=20,所以延迟调用时打印的仍是函数在定义时的值。

### 获取命令行参数
```go
package main

import "fmt"
import "os"

func main() {

	arg_list := os.Args
	for i := 0; i < len(arg_list); i++ {
		fmt.Printf("args_list[%d]=%s\n", i, arg_list[i])
	}
}
```

### local variable
local variable only works in it's define env
```go
package main

import "fmt"

func main() {
	// 定义在 {}里的变量就是局部变量
	// 只能在{}里面用，作用域就是当前{}
	if flag := 0; flag == 0 {
		fmt.Println("flag=", flag)
	}
	// flag = 1 
	// flag 的作用域仅仅为if语句，出了它就失效了
}
```

### global variable
global var should define like: var var_name type
```go
package main

import "fmt"

var global_var int

func main() {
	global_var = 100
	fmt.Println("global_var=", global_var)
}
```

### same variable name in diff env
同一变量名，在不同作用域下取值遵循就近原则。
```go
package main

import "fmt"

var a byte

func main() {
	var a int
	fmt.Printf("1:type of a is %T\n", a) // int
	{
		var a float32
		fmt.Printf("2:type of a is %T\n", a) // float 32
	}
	test()
}

func test() {
	fmt.Printf("3:type of a is %T\n", a) // byte
}
```

### 闭包

```go
package main

import 'fmt'

# func(int) int 整体作为返回值
# x为Adder的变量被返回值函数引用
func Adder() func(int) int{
    var x int 
    return func(d int) int{
        x += d
        return x
    }
}

func main(){
    f := Adder()
    fmt.Println(f(1)) #1
    fmt.Println(f(10)) #11
    fmt.Println(f(10)) #111
}
```

判断一个元素是否在一个数组中

```go
func inArray(arr []int, target int) bool {
    numMap := make(map[int]bool)
    for _, v := range arr {
        numMap[v] = true
    }
    _, ok := numMap[target]
    return ok
}
```
### 判断数组是否在另一个数组内部

```go
func contains(arr [][]int, s []int) bool {
    // check if x in arr
    for _, v := range arr{
        if reflect.DeepEqual(v, s) {
            return true
        }
    }
    return false
}
```